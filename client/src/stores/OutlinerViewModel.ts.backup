// @ts-nocheck
// Fluid Frameworké–¢é€£ã®importã¯å‰Šé™¤ï¼ˆYjsãƒ¢ãƒ¼ãƒ‰ã®ã¿ï¼‰
import { getLogger } from "../lib/logger";
import type { YjsOrderedTreeManager } from "../lib/yjsOrderedTreeManager.svelte";

const logger = getLogger();

// Yjsã‚¢ã‚¤ãƒ†ãƒ ã®å‚ç…§æƒ…å ±
export interface YjsItemReference {
    treeManager: YjsOrderedTreeManager;
    yjsItemId: string;
}

// ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ‡ãƒ«ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼ˆFluid + Yjs 1:1:1å¯¾å¿œï¼‰
export interface OutlinerItemViewModel {
    id: string;
    original: Item; // å…ƒã®Fluidã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§
    yjsRef?: YjsItemReference; // å¯¾å¿œã™ã‚‹Yjsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§
    text: string;
    votes: string[];
    author: string;
    created: number;
    lastChanged: number;
    commentCount: number;
}

// è¡¨ç¤ºç”¨ã®ã‚¢ã‚¤ãƒ†ãƒ æƒ…å ±
export interface DisplayItem {
    model: OutlinerItemViewModel;
    depth: number;
    parentId: string | null;
}

/**
 * ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒŠãƒ¼ã®ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ‡ãƒ«ã‚’ç®¡ç†ã™ã‚‹ã‚¹ãƒˆã‚¢
 * DOMã®å†ç”Ÿæˆã‚’é¿ã‘ã‚‹ãŸã‚ã«ã€ã‚¢ã‚¤ãƒ†ãƒ ã®å‚ç…§åŒä¸€æ€§ã‚’ç¶­æŒã™ã‚‹
 * Fluid + Yjs 1:1:1å¯¾å¿œã‚’ç®¡ç†ã™ã‚‹
 */
export class OutlinerViewModel {
    // IDã«ã‚ˆã‚‹ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ‡ãƒ«ãƒãƒƒãƒ—ï¼ˆå‚ç…§åŒä¸€æ€§ã‚’ç¶­æŒï¼‰
    private viewModels = new Map<string, OutlinerItemViewModel>();

    // è¡¨ç¤ºé †åºã‚’ç¤ºã™IDé…åˆ—
    private visibleOrder: string[] = [];

    // ã‚¢ã‚¤ãƒ†ãƒ ã®æ·±åº¦ãƒãƒƒãƒ—
    private depthMap = new Map<string, number>();

    // è¦ªã‚¢ã‚¤ãƒ†ãƒ IDã®ãƒãƒƒãƒ—
    private parentMap = new Map<string, string | null>();

    // æŠ˜ã‚ŠãŸãŸã¿çŠ¶æ…‹ã®ãƒãƒƒãƒ—
    private collapsedMap = new Map<string, boolean>();

    // æ›´æ–°ä¸­ãƒ•ãƒ©ã‚°
    private _isUpdating = false;

    // Yjsçµ±åˆç”¨ã®ãƒšãƒ¼ã‚¸TreeManagerï¼ˆãƒšãƒ¼ã‚¸ã”ã¨ã«1ã¤ï¼‰
    private pageTreeManager?: YjsOrderedTreeManager;

    // Yjsä½œæˆä¸­ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¿½è·¡ï¼ˆé‡è¤‡ä½œæˆã‚’é˜²ãï¼‰
    private creatingYjsItems = new Set<string>();

    /**
     * ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«ã‹ã‚‰ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ‡ãƒ«ã‚’æ›´æ–°ã™ã‚‹
     * @param pageItem ãƒ«ãƒ¼ãƒˆã‚¢ã‚¤ãƒ†ãƒ ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³
     */
    updateFromModel(pageItem: Item): void {
        // æ›´æ–°ä¸­ã«æ—¢ã«å‡¦ç†ä¸­ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
        if (this._isUpdating) return;

        try {
            this._isUpdating = true;

            console.log("ğŸ”§ [OutlinerViewModel] updateFromModel called");
            console.log(
                "ğŸ”§ [OutlinerViewModel] pageItem.items length:",
                (pageItem.items as any)?.length || 0,
            );

            // ã¾ãšãƒ«ãƒ¼ãƒˆï¼ˆãƒšãƒ¼ã‚¸ï¼‰ã‚¢ã‚¤ãƒ†ãƒ è‡ªä½“ã®ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ‡ãƒ«ã‚’ç¢ºä¿ã—ã€è¡¨ç¤ºé †åºã®å…ˆé ­ã«å«ã‚ã‚‹
            this.ensureViewModelsItemExist(pageItem, null);

            // ãƒšãƒ¼ã‚¸ã‚¢ã‚¤ãƒ†ãƒ ã®å­ã‚¢ã‚¤ãƒ†ãƒ ã‚’å‡¦ç†
            if (pageItem.items && Tree.is(pageItem.items, Items)) {
                this.ensureViewModelsItemsExist(pageItem.items, pageItem.id);
            }

            console.log(
                "ğŸ”§ [OutlinerViewModel] viewModels count after ensure:",
                this.viewModels.size,
            );
            console.log(
                "ğŸ”§ [OutlinerViewModel] viewModel IDs:",
                Array.from(this.viewModels.keys()).join(", "),
            );

            // æ–°ã—ãè¿½åŠ ã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ã«å¯¾ã—ã¦Yjsçµ±åˆã‚’å®Ÿè¡Œï¼ˆãƒ¡ã‚½ãƒƒãƒ‰å†…ã§ç„¡åŠ¹åŒ–æ¸ˆã¿ï¼‰
            this.ensureYjsItemsForNewViewModels();

            // è¡¨ç¤ºé †åºã¨æ·±åº¦ã‚’å†è¨ˆç®— - ãƒ«ãƒ¼ãƒˆã‚’å«ã‚ã¦é–‹å§‹
            this.visibleOrder = [];
            this.depthMap.clear();
            this.parentMap.clear();
            this.recalculateOrderAndDepthItem(pageItem, 0, null);

            console.log(
                "ğŸ”§ [OutlinerViewModel] visibleOrder length after recalculate:",
                this.visibleOrder.length,
            );
            logger.info("View models updated, count:", this.visibleOrder.length);
        } finally {
            this._isUpdating = false;
        }
    }

    /**
     * ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ‡ãƒ«ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã€å¿…è¦ã«å¿œã˜ã¦ä½œæˆã¾ãŸã¯æ›´æ–°ã™ã‚‹
     */
    private ensureViewModelsItemsExist(
        items: Items,
        parentId: string | null = null,
    ): void {
        if (!items) return;

        for (let i = 0; i < items.length; i++) {
            this.ensureViewModelsItemExist(items[i], parentId);
        }
    }

    private ensureViewModelsItemExist(
        item: Item,
        parentId: string | null = null,
    ): void {
        if (!Tree.is(item, Item) || !item.id) return;

        console.log(
            `OutlinerViewModel: ensureViewModelsItemExist for item "${item.text}" (id: ${item.id})`,
        );

        // æ—¢å­˜ã®ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ‡ãƒ«ã‚’æ›´æ–°ã¾ãŸã¯æ–°è¦ä½œæˆ
        const existingViewModel = this.viewModels.get(item.id);
        if (existingViewModel) {
            // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æ›´æ–°ï¼ˆå‚ç…§ã¯ç¶­æŒï¼‰
            existingViewModel.text = item.text;
            existingViewModel.votes = [...item.votes];
            existingViewModel.lastChanged = item.lastChanged;
            existingViewModel.commentCount = item.comments?.length ?? 0;
            console.log(
                `OutlinerViewModel: Updated existing view model for "${item.text}"`,
            );
        } else {
            // æ–°ã—ã„ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ‡ãƒ«ã‚’ä½œæˆ
            this.viewModels.set(item.id, {
                id: item.id,
                original: item,
                text: item.text,
                votes: [...item.votes],
                author: item.author,
                created: item.created,
                lastChanged: item.lastChanged,
                commentCount: item.comments?.length ?? 0,
            });
            console.log(
                `OutlinerViewModel: Created new view model for "${item.text}"`,
            );
        }

        // è¦ªã®è¨­å®š
        this.parentMap.set(item.id, parentId);

        // å­ã‚¢ã‚¤ãƒ†ãƒ ã‚‚å‡¦ç†
        if (item.items && Tree.is(item.items, Items)) {
            const children = item.items as any;
            console.log(
                `OutlinerViewModel: Processing ${children.length} children for "${item.text}"`,
            );
            this.ensureViewModelsItemsExist(children, item.id);
        } else {
            console.log(`OutlinerViewModel: No children for "${item.text}"`);
        }
    }
    /**
     * è¡¨ç¤ºé †åºã¨æ·±åº¦ã‚’å†è¨ˆç®—ã™ã‚‹
     */
    private recalculateOrderAndDepth(
        items: Items,
        depth: number = 0,
        parentId: string | null = null,
    ): void {
        if (!items) return;

        // è¡¨ç¤ºé †åºã¨æ·±åº¦ã‚’æœ€åˆã«åˆæœŸåŒ–
        if (depth === 0) {
            this.visibleOrder = [];
        }

        for (let i = 0; i < items.length; i++) {
            this.recalculateOrderAndDepthItem(items[i], depth, parentId);
        }
    }
    /**
     * è¡¨ç¤ºé †åºã¨æ·±åº¦ã‚’å†è¨ˆç®—ã™ã‚‹ï¼ˆå˜ä¸€ã‚¢ã‚¤ãƒ†ãƒ ç”¨ï¼‰
     */
    private recalculateOrderAndDepthItem(
        item: Item,
        depth: number = 0,
        parentId: string | null = null,
    ): void {
        if (!Tree.is(item, Item) || !item.id) return;

        console.log(
            `OutlinerViewModel: recalculateOrderAndDepthItem for "${item.text}" (depth: ${depth})`,
        );

        // è¡¨ç¤ºé †åºã«è¿½åŠ 
        this.visibleOrder.push(item.id);

        // æ·±åº¦ã‚’è¨­å®š
        this.depthMap.set(item.id, depth);
        const vm = this.viewModels.get(item.id);
        if (vm) {
            vm.commentCount = item.comments?.length ?? 0;
        }

        // å­ã‚¢ã‚¤ãƒ†ãƒ ã‚’å‡¦ç†ï¼ˆæŠ˜ã‚ŠãŸãŸã¾ã‚Œã¦ã„ãªã„å ´åˆã®ã¿ï¼‰
        const isCollapsed = this.collapsedMap.get(item.id);
        const hasChildren = item.items && Tree.is(item.items, Items) && (item.items as any).length > 0;

        console.log(
            `OutlinerViewModel: Item "${item.text}" - hasChildren: ${hasChildren}, isCollapsed: ${isCollapsed}, childrenCount: ${
                hasChildren ? item.items.length : 0
            }`,
        );

        if (hasChildren && !isCollapsed) {
            const children = item.items as any;
            console.log(
                `OutlinerViewModel: Processing ${children.length} children for "${item.text}"`,
            );
            for (let i = 0; i < children.length; i++) {
                this.recalculateOrderAndDepthItem(children[i], depth + 1, item.id);
            }
        } else if (hasChildren && isCollapsed) {
            console.log(
                `OutlinerViewModel: Skipping children for "${item.text}" because it's collapsed`,
            );
        } else if (!hasChildren) {
            console.log(`OutlinerViewModel: No children for "${item.text}"`);
        }
    }

    /**
     * ã‚¢ã‚¤ãƒ†ãƒ ã®æŠ˜ã‚ŠãŸãŸã¿çŠ¶æ…‹ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹
     */
    toggleCollapsed(itemId: string): void {
        const isCollapsed = this.collapsedMap.get(itemId) || false;
        this.collapsedMap.set(itemId, !isCollapsed);

        // ãƒ¢ãƒ‡ãƒ«ã‹ã‚‰è¡¨ç¤ºæƒ…å ±ã‚’å†è¨ˆç®—ï¼ˆã‚¢ã‚¤ãƒ†ãƒ ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ç¶­æŒï¼‰
        const rootItem = this.findRootItem(itemId);
        if (rootItem && rootItem.items && Tree.is(rootItem.items, Items)) {
            this.recalculateOrderAndDepth(rootItem.items);
        }
    }

    /**
     * ãƒ«ãƒ¼ãƒˆã‚¢ã‚¤ãƒ†ãƒ ã‚’è¦‹ã¤ã‘ã‚‹
     */
    private findRootItem(itemId: string): Item | null {
        const item = this.viewModels.get(itemId)?.original;
        if (!item) return null;

        let current = item;
        let parent: unknown;

        // ãƒ«ãƒ¼ãƒˆã«åˆ°é”ã™ã‚‹ã¾ã§è¦ªã‚’è¾¿ã‚‹
        while ((parent = Tree.parent(current)) && Tree.is(parent, Item)) {
            current = parent;
        }

        return current;
    }

    /**
     * è¡¨ç¤ºç”¨ã®ã‚¢ã‚¤ãƒ†ãƒ ãƒªã‚¹ãƒˆã‚’å–å¾—ã™ã‚‹
     */
    getVisibleItems(): DisplayItem[] {
        return this.visibleOrder
            .map(id => {
                const model = this.viewModels.get(id);
                if (!model) {
                    logger.error("View model not found for ID:", id);
                    return null;
                }

                return {
                    model,
                    depth: this.depthMap.get(id) || 0,
                    parentId: this.parentMap.get(id) || null,
                };
            })
            .filter((item): item is DisplayItem => item !== null);
    }

    /**
     * ã‚¢ã‚¤ãƒ†ãƒ ã®æŠ˜ã‚ŠãŸãŸã¿çŠ¶æ…‹ã‚’å–å¾—
     */
    isCollapsed(itemId: string): boolean {
        return this.collapsedMap.get(itemId) || false;
    }

    /**
     * ã‚¢ã‚¤ãƒ†ãƒ ãŒå­ã‚’æŒã£ã¦ã„ã‚‹ã‹ã‚’ç¢ºèª
     */
    hasChildren(itemId: string): boolean {
        const model = this.viewModels.get(itemId);
        if (!model || !model.original || !model.original.items) return false;
        return (
            Tree.is(model.original.items, Items) && model.original.items.length > 0
        );
    }

    /**
     * ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ‡ãƒ«ã‚’ç›´æ¥å–å¾—
     */
    getViewModel(id: string): OutlinerItemViewModel | undefined {
        return this.viewModels.get(id);
    }

    /**
     * Yjs TreeManagerã‚’è¨­å®šï¼ˆãƒšãƒ¼ã‚¸æ¥ç¶šæ™‚ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ï¼‰
     */
    setYjsTreeManager(treeManager: YjsOrderedTreeManager): void {
        this.pageTreeManager = treeManager;
        console.log("OutlinerViewModel: Yjs TreeManager set");
    }



    /**
     * æ–°ã—ãè¿½åŠ ã•ã‚ŒãŸãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ‡ãƒ«ã«å¯¾ã—ã¦Yjsçµ±åˆã‚’å®Ÿè¡Œ
     * æ—¢å­˜ã®Yjsã‚¢ã‚¤ãƒ†ãƒ ã¨ã®1:1å¯¾å¿œã‚’ç¢ºç«‹ï¼ˆãƒ‡ãƒ¼ã‚¿åŒæœŸã§ã¯ãªãå‚ç…§ã®ç¢ºç«‹ï¼‰
     */
    private ensureYjsItemsForNewViewModels(): void {
        if (!this.pageTreeManager) {
            console.log("ğŸ”§ [OutlinerViewModel] ensureYjsItemsForNewViewModels: TreeManager not available");
            return;
        }

        let integrationCount = 0;
        let totalViewModels = 0;

        // å…¨ã¦ã®ViewModelã«å¯¾ã—ã¦Yjså‚ç…§ã‚’ç¢ºç«‹
        for (const [fluidItemId, viewModel] of this.viewModels) {
            totalViewModels++;

            // æ—¢ã«Yjså‚ç…§ãŒã‚ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
            if (viewModel.yjsRef) {
                integrationCount++;
                continue;
            }

            // Yjsã‚¢ã‚¤ãƒ†ãƒ ãŒFluidã‚¢ã‚¤ãƒ†ãƒ IDã¨åŒã˜IDã§å­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            try {
                const yjsItem = this.pageTreeManager.getItem(fluidItemId);
                if (yjsItem) {
                    // Yjså‚ç…§ã‚’è¨­å®š
                    viewModel.yjsRef = {
                        treeManager: this.pageTreeManager,
                        yjsItemId: fluidItemId,
                    };
                    integrationCount++;
                    console.log(`ğŸ”§ [OutlinerViewModel] Established Yjs reference for item: ${fluidItemId}`);

                    // æ—¢å­˜ã®Yjsã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ†ã‚­ã‚¹ãƒˆãŒFluidã‚¢ã‚¤ãƒ†ãƒ ã¨ç•°ãªã‚‹å ´åˆã¯åŒæœŸ
                    if (yjsItem.text !== viewModel.text) {
                        console.log(`ğŸ”§ [OutlinerViewModel] Syncing text for existing Yjs item ${fluidItemId}: "${yjsItem.text}" -> "${viewModel.text}"`);
                        // éåŒæœŸå‡¦ç†ã‚’åŒæœŸçš„ã«å®Ÿè¡Œï¼ˆPromise.resolve()ã§åŒ…ã‚€ï¼‰
                        this.pageTreeManager.updateItemText(fluidItemId, viewModel.text)
                            .then(() => {
                                console.log(`ğŸ”§ [OutlinerViewModel] âœ… Synced text for existing Yjs item: ${fluidItemId}`);
                            })
                            .catch((syncError) => {
                                console.error(`ğŸ”§ [OutlinerViewModel] âŒ Failed to sync text for existing Yjs item ${fluidItemId}:`, syncError);
                            });
                    }
                } else {
                    // å¯¾å¿œã™ã‚‹Yjsã‚¢ã‚¤ãƒ†ãƒ ãŒå­˜åœ¨ã—ãªã„å ´åˆã€æ–°è¦ä½œæˆï¼ˆUIå±¤ã§ã®1:1:1å¯¾å¿œç¢ºç«‹ï¼‰
                    console.log(`ğŸ”§ [OutlinerViewModel] Creating new Yjs item for Fluid item: ${fluidItemId}`);

                    try {
                        // æ­£ã—ã„ä½ç½®ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã€å‰ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¢ã™
                        let afterItemId: string | undefined = undefined;
                        const allViewModelIds = Array.from(this.viewModels.keys());
                        const currentIndex = allViewModelIds.indexOf(fluidItemId);

                        // å‰ã®ã‚¢ã‚¤ãƒ†ãƒ ã§Yjså‚ç…§ãŒã‚ã‚‹ã‚‚ã®ã‚’æ¢ã™
                        for (let i = currentIndex - 1; i >= 0; i--) {
                            const prevViewModel = this.viewModels.get(allViewModelIds[i]);
                            if (prevViewModel?.yjsRef) {
                                afterItemId = prevViewModel.yjsRef.yjsItemId;
                                console.log(`ğŸ”§ [OutlinerViewModel] Found previous Yjs item for positioning: ${afterItemId}`);
                                break;
                            }
                        }

                        // ã‚¿ã‚¤ãƒˆãƒ«ãƒãƒ¼ãƒ‰ã‚’æ¢ã—ã¦ãã®é…ä¸‹ã«é…ç½®
                        const rootItems = this.pageTreeManager.getRootItems();
                        const titleNode = rootItems.find(item => item.text === this.pageTitle);
                        const parentId = titleNode ? titleNode.id : undefined;

                        const yjsItemId = this.pageTreeManager.insertItem(
                            viewModel.text,
                            viewModel.author,
                            parentId, // parentId - ã‚¿ã‚¤ãƒˆãƒ«ãƒãƒ¼ãƒ‰é…ä¸‹
                            afterItemId, // afterItemId - å‰ã®ã‚¢ã‚¤ãƒ†ãƒ ã®å¾Œã«é…ç½®
                            fluidItemId // customItemId - Fluidã‚¢ã‚¤ãƒ†ãƒ IDã¨åŒã˜IDã‚’ä½¿ç”¨
                        );

                        // Yjså‚ç…§ã‚’è¨­å®š
                        viewModel.yjsRef = {
                            treeManager: this.pageTreeManager,
                            yjsItemId: yjsItemId,
                        };
                        integrationCount++;

                        console.log(`ğŸ”§ [OutlinerViewModel] âœ… Created new Yjs item: ${yjsItemId} for Fluid item: ${fluidItemId} after: ${afterItemId || 'start'}`);
                    } catch (createError) {
                        console.error(`ğŸ”§ [OutlinerViewModel] âŒ Failed to create Yjs item for ${fluidItemId}:`, createError);
                    }
                }
            } catch (error) {
                console.warn(`ğŸ”§ [OutlinerViewModel] Error checking Yjs item ${fluidItemId}:`, error);
            }
        }

        console.log(
            `ğŸ”§ [OutlinerViewModel] Integration status: ${integrationCount}/${totalViewModels} items have Yjs references`,
        );

        // çµ±åˆå®Œäº†ã®åˆ¤å®š
        if (integrationCount === totalViewModels && totalViewModels > 0) {
            console.log(`ğŸ”§ [OutlinerViewModel] Yjs integration completed`);
        }
    }

    /**
     * Yjsã‚¢ã‚¤ãƒ†ãƒ ã®é †åºã‚’ãƒ­ã‚°å‡ºåŠ›
     */
    private logYjsItemOrder(parentId?: string): void {
        try {
            if (!this.pageTreeManager) return;

            let items: any[] = [];

            if (parentId) {
                // è¦ªã‚¢ã‚¤ãƒ†ãƒ ã®å­ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
                const parentViewModel = this.viewModels.get(parentId);
                if (parentViewModel?.yjsRef) {
                    const parentYjsId = parentViewModel.yjsRef.yjsItemId;
                    console.log(`ğŸ”§ [OutlinerViewModel] Getting children for parent Yjs ID: ${parentYjsId}`);
                    items = this.pageTreeManager.getChildren(parentYjsId) || [];
                    console.log(`ğŸ”§ [OutlinerViewModel] Found ${items.length} children for parent ${parentYjsId}`);
                } else {
                    console.log(`ğŸ”§ [OutlinerViewModel] Parent ViewModel or Yjs ref not found for ${parentId}`);
                }
            } else {
                // ãƒ«ãƒ¼ãƒˆãƒ¬ãƒ™ãƒ«ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
                console.log(`ğŸ”§ [OutlinerViewModel] Getting root items`);
                items = this.pageTreeManager.getRootItems() || [];
                console.log(`ğŸ”§ [OutlinerViewModel] Found ${items.length} root items`);
            }

            console.log(`ğŸ”§ [OutlinerViewModel] Yjs item order for parent ${parentId || "root"}:`);
            console.log(`ğŸ”§ [OutlinerViewModel] Items array length: ${items.length}`);
            items.forEach((item, index) => {
                console.log(`  ${index}: id=${item?.id || "no-id"}, text="${item?.text || "no-text"}"`);
                console.log(`    Keys:`, Object.keys(item || {}));
                console.log(`    Type:`, typeof item);
                if (item && typeof item === "object") {
                    console.log(`    Properties: id=${item.id}, text=${item.text}, author=${item.author}`);
                }
            });
        } catch (error) {
            console.error(`ğŸ”§ [OutlinerViewModel] Failed to log Yjs item order:`, error);
        }
    }

    /**
     * Fluidã‚¢ã‚¤ãƒ†ãƒ ã®å‰ã«ã‚ã‚‹Yjsã‚¢ã‚¤ãƒ†ãƒ ã‚’è¦‹ã¤ã‘ã‚‹
     */
    private findPreviousYjsItem(fluidItemId: string, parentId?: string): string | null {
        try {
            // è¦ªã‚¢ã‚¤ãƒ†ãƒ ã®å­ã‚¢ã‚¤ãƒ†ãƒ ãƒªã‚¹ãƒˆã‚’å–å¾—
            let siblingItems: string[] = [];

            if (parentId) {
                // è¦ªã‚¢ã‚¤ãƒ†ãƒ ã®å­ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
                const parentViewModel = this.viewModels.get(parentId);
                if (parentViewModel) {
                    // è¦ªã®å­ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—ï¼ˆFluidã‹ã‚‰ï¼‰
                    const parentItem = parentViewModel.original;
                    if (parentItem.items && Tree.is(parentItem.items, Items)) {
                        siblingItems = Array.from(parentItem.items).map(item => item.id as string);
                    }
                }
            } else {
                // ãƒ«ãƒ¼ãƒˆãƒ¬ãƒ™ãƒ«ã®ã‚¢ã‚¤ãƒ†ãƒ ã®å ´åˆã€ãƒšãƒ¼ã‚¸ã‚¢ã‚¤ãƒ†ãƒ ã®å­ã‚’å–å¾—
                if (this.pageItem && this.pageItem.items && Tree.is(this.pageItem.items, Items)) {
                    siblingItems = Array.from(this.pageItem.items).map(item => item.id as string);
                }
            }

            // å¯¾è±¡ã‚¢ã‚¤ãƒ†ãƒ ã®ä½ç½®ã‚’è¦‹ã¤ã‘ã‚‹
            const fluidIndex = siblingItems.indexOf(fluidItemId);
            if (fluidIndex === -1) {
                return null;
            }

            // å‰ã®ã‚¢ã‚¤ãƒ†ãƒ ã§Yjså‚ç…§ãŒã‚ã‚‹ã‚‚ã®ã‚’æ¢ã™
            for (let i = fluidIndex - 1; i >= 0; i--) {
                const siblingViewModel = this.viewModels.get(siblingItems[i]);
                if (siblingViewModel?.yjsRef) {
                    return siblingViewModel.yjsRef.yjsItemId;
                }
            }

            return null;
        } catch (error) {
            console.error(`ğŸ”§ [OutlinerViewModel] Failed to find previous Yjs item for ${fluidItemId}:`, error);
            return null;
        }
    }

    /**
     * Yjsã‚¢ã‚¤ãƒ†ãƒ ã‚’Fluidã‚¢ã‚¤ãƒ†ãƒ ã¨åŒã˜ä½ç½®ã«é…ç½®
     */
    private positionYjsItem(fluidItemId: string, yjsItemId: string, parentId?: string): void {
        try {
            // è¦ªã‚¢ã‚¤ãƒ†ãƒ ã®å­ã‚¢ã‚¤ãƒ†ãƒ ãƒªã‚¹ãƒˆã‚’å–å¾—
            let siblingItems: string[] = [];

            if (parentId) {
                // è¦ªã‚¢ã‚¤ãƒ†ãƒ ã®å­ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
                const parentViewModel = this.viewModels.get(parentId);
                if (parentViewModel) {
                    // è¦ªã®å­ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—ï¼ˆFluidã‹ã‚‰ï¼‰
                    const parentItem = parentViewModel.original;
                    if (parentItem.items && Tree.is(parentItem.items, Items)) {
                        siblingItems = Array.from(parentItem.items).map(item => item.id as string);
                    }
                }
            } else {
                // ãƒ«ãƒ¼ãƒˆãƒ¬ãƒ™ãƒ«ã®ã‚¢ã‚¤ãƒ†ãƒ ã®å ´åˆã€ãƒšãƒ¼ã‚¸ã‚¢ã‚¤ãƒ†ãƒ ã®å­ã‚’å–å¾—
                if (this.pageItem && this.pageItem.items && Tree.is(this.pageItem.items, Items)) {
                    siblingItems = Array.from(this.pageItem.items).map(item => item.id as string);
                }
            }

            console.log(`ğŸ”§ [OutlinerViewModel] Positioning Yjs item ${yjsItemId} for Fluid item ${fluidItemId}`);
            console.log(`ğŸ”§ [OutlinerViewModel] Sibling items:`, siblingItems);

            // å¯¾è±¡ã‚¢ã‚¤ãƒ†ãƒ ã®ä½ç½®ã‚’è¦‹ã¤ã‘ã‚‹
            const fluidIndex = siblingItems.indexOf(fluidItemId);
            if (fluidIndex === -1) {
                console.warn(`ğŸ”§ [OutlinerViewModel] Fluid item ${fluidItemId} not found in sibling list`);
                return;
            }

            console.log(`ğŸ”§ [OutlinerViewModel] Fluid item ${fluidItemId} is at index ${fluidIndex}`);

            // å‰ã®ã‚¢ã‚¤ãƒ†ãƒ ã§Yjså‚ç…§ãŒã‚ã‚‹ã‚‚ã®ã‚’æ¢ã™
            let previousYjsItemId: string | null = null;
            for (let i = fluidIndex - 1; i >= 0; i--) {
                const siblingViewModel = this.viewModels.get(siblingItems[i]);
                console.log(
                    `ğŸ”§ [OutlinerViewModel] Checking sibling ${siblingItems[i]}: yjsRef=${!!siblingViewModel?.yjsRef}`,
                );
                if (siblingViewModel?.yjsRef) {
                    previousYjsItemId = siblingViewModel.yjsRef.yjsItemId;
                    console.log(
                        `ğŸ”§ [OutlinerViewModel] Found previous Yjs item: ${previousYjsItemId} (Fluid: ${
                            siblingItems[i]
                        })`,
                    );
                    break;
                }
            }

            if (previousYjsItemId) {
                // å‰ã®ã‚¢ã‚¤ãƒ†ãƒ ã®å¾Œã«é…ç½®
                try {
                    this.pageTreeManager.getTree().setNodeAfter(yjsItemId, previousYjsItemId);
                    console.log(
                        `ğŸ”§ [OutlinerViewModel] âœ… Positioned Yjs item ${yjsItemId} after ${previousYjsItemId}`,
                    );
                } catch (error) {
                    console.error(
                        `ğŸ”§ [OutlinerViewModel] âŒ Failed to position Yjs item ${yjsItemId} after ${previousYjsItemId}:`,
                        error,
                    );

                    // setNodeAfterãŒå¤±æ•—ã—ãŸå ´åˆã€setNodeBeforeã‚’è©¦ã™
                    try {
                        // æ¬¡ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¦‹ã¤ã‘ã¦ã€ãã®å‰ã«é…ç½®
                        let nextYjsItemId: string | null = null;
                        for (let i = fluidIndex + 1; i < siblingItems.length; i++) {
                            const siblingViewModel = this.viewModels.get(siblingItems[i]);
                            if (siblingViewModel?.yjsRef) {
                                nextYjsItemId = siblingViewModel.yjsRef.yjsItemId;
                                break;
                            }
                        }

                        if (nextYjsItemId) {
                            this.pageTreeManager.getTree().setNodeBefore(yjsItemId, nextYjsItemId);
                            console.log(
                                `ğŸ”§ [OutlinerViewModel] âœ… Positioned Yjs item ${yjsItemId} before ${nextYjsItemId} (fallback)`,
                            );
                        }
                    } catch (fallbackError) {
                        console.error(`ğŸ”§ [OutlinerViewModel] âŒ Fallback positioning also failed:`, fallbackError);
                    }
                }
            } else {
                console.log(`ğŸ”§ [OutlinerViewModel] Yjs item ${yjsItemId} positioned at beginning (no previous item)`);
            }
        } catch (error) {
            console.error(`ğŸ”§ [OutlinerViewModel] Failed to position Yjs item ${yjsItemId}:`, error);
        }
    }

    /**
     * Fluidã‚¢ã‚¤ãƒ†ãƒ ã®ä½ç½®ã«åŸºã¥ã„ã¦Yjsã‚¢ã‚¤ãƒ†ãƒ ã®æŒ¿å…¥ä½ç½®ã‚’è¨ˆç®—
     */
    private calculateInsertIndex(fluidItemId: string, parentId?: string): number {
        // è¦ªã‚¢ã‚¤ãƒ†ãƒ ã®å­ã‚¢ã‚¤ãƒ†ãƒ ãƒªã‚¹ãƒˆã‚’å–å¾—
        let siblingItems: string[] = [];

        if (parentId) {
            // è¦ªã‚¢ã‚¤ãƒ†ãƒ ã®å­ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
            const parentViewModel = this.viewModels.get(parentId);
            if (parentViewModel) {
                // è¦ªã®å­ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—ï¼ˆFluidã‹ã‚‰ï¼‰
                const parentItem = parentViewModel.original;
                if (parentItem.items && Tree.is(parentItem.items, Items)) {
                    siblingItems = Array.from(parentItem.items).map(item => item.id as string);
                }
            }
        } else {
            // ãƒ«ãƒ¼ãƒˆãƒ¬ãƒ™ãƒ«ã®ã‚¢ã‚¤ãƒ†ãƒ ã®å ´åˆã€ãƒšãƒ¼ã‚¸ã‚¢ã‚¤ãƒ†ãƒ ã®å­ã‚’å–å¾—
            if (this.pageItem && this.pageItem.items && Tree.is(this.pageItem.items, Items)) {
                siblingItems = Array.from(this.pageItem.items).map(item => item.id as string);
            }
        }

        // å¯¾è±¡ã‚¢ã‚¤ãƒ†ãƒ ã®ä½ç½®ã‚’è¦‹ã¤ã‘ã‚‹
        const fluidIndex = siblingItems.indexOf(fluidItemId);
        if (fluidIndex === -1) {
            console.warn(
                `ğŸ”§ [OutlinerViewModel] Fluid item ${fluidItemId} not found in sibling list, inserting at end`,
            );
            return -1; // æœ«å°¾ã«æŒ¿å…¥
        }

        // Yjsã«æ—¢ã«å­˜åœ¨ã™ã‚‹å…„å¼Ÿã‚¢ã‚¤ãƒ†ãƒ ã®æ•°ã‚’æ•°ãˆã‚‹
        let yjsIndex = 0;
        for (let i = 0; i < fluidIndex; i++) {
            const siblingViewModel = this.viewModels.get(siblingItems[i]);
            if (siblingViewModel?.yjsRef) {
                yjsIndex++;
            }
        }

        console.log(
            `ğŸ”§ [OutlinerViewModel] Fluid index: ${fluidIndex}, Yjs index: ${yjsIndex} for item ${fluidItemId}`,
        );
        return yjsIndex;
    }

    /**
     * Fluidã‚¢ã‚¤ãƒ†ãƒ ã¨Yjsã‚¢ã‚¤ãƒ†ãƒ ã®1:1å¯¾å¿œã‚’ç¢ºç«‹
     * æ—¢å­˜ã®Yjsã‚¢ã‚¤ãƒ†ãƒ ã¨ã®å‚ç…§ã‚’ç¢ºç«‹ã€å­˜åœ¨ã—ãªã„å ´åˆã¯æ–°è¦ä½œæˆ
     */
    async ensureYjsItemExists(fluidItemId: string): Promise<string | null> {
        if (!this.pageTreeManager) {
            console.log(`ğŸ”§ [OutlinerViewModel] ensureYjsItemExists: TreeManager not available for ${fluidItemId}`);
            return null;
        }

        const viewModel = this.viewModels.get(fluidItemId);
        if (!viewModel) {
            console.log(`ğŸ”§ [OutlinerViewModel] ensureYjsItemExists: ViewModel not found for ${fluidItemId}`);
            return null;
        }

        // æ—¢ã«Yjså‚ç…§ãŒã‚ã‚‹å ´åˆã¯ãã‚Œã‚’è¿”ã™
        if (viewModel.yjsRef) {
            return viewModel.yjsRef.yjsItemId;
        }

        // Yjsã‚¢ã‚¤ãƒ†ãƒ ãŒFluidã‚¢ã‚¤ãƒ†ãƒ IDã¨åŒã˜IDã§å­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        try {
            const yjsItem = this.pageTreeManager.getItem(fluidItemId);
            if (yjsItem) {
                // Yjså‚ç…§ã‚’è¨­å®š
                viewModel.yjsRef = {
                    treeManager: this.pageTreeManager,
                    yjsItemId: fluidItemId,
                };
                console.log(`ğŸ”§ [OutlinerViewModel] Established Yjs reference for existing item: ${fluidItemId}`);

                // æ—¢å­˜ã®Yjsã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ†ã‚­ã‚¹ãƒˆãŒFluidã‚¢ã‚¤ãƒ†ãƒ ã¨ç•°ãªã‚‹å ´åˆã¯åŒæœŸ
                if (yjsItem.text !== viewModel.text) {
                    console.log(`ğŸ”§ [OutlinerViewModel] Syncing text for existing Yjs item ${fluidItemId}: "${yjsItem.text}" -> "${viewModel.text}"`);
                    // éåŒæœŸå‡¦ç†ã‚’åŒæœŸçš„ã«å®Ÿè¡Œï¼ˆPromise.resolve()ã§åŒ…ã‚€ï¼‰
                    this.pageTreeManager.updateItemText(fluidItemId, viewModel.text)
                        .then(() => {
                            console.log(`ğŸ”§ [OutlinerViewModel] âœ… Synced text for existing Yjs item: ${fluidItemId}`);
                        })
                        .catch((syncError) => {
                            console.error(`ğŸ”§ [OutlinerViewModel] âŒ Failed to sync text for existing Yjs item ${fluidItemId}:`, syncError);
                        });
                }

                return fluidItemId;
            } else {
                // å¯¾å¿œã™ã‚‹Yjsã‚¢ã‚¤ãƒ†ãƒ ãŒå­˜åœ¨ã—ãªã„å ´åˆã€æ–°è¦ä½œæˆï¼ˆUIå±¤ã§ã®1:1:1å¯¾å¿œç¢ºç«‹ï¼‰
                console.log(`ğŸ”§ [OutlinerViewModel] Creating new Yjs item for Fluid item: ${fluidItemId}`);

                try {
                    // æ­£ã—ã„ä½ç½®ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã€å‰ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¢ã™
                    let afterItemId: string | undefined = undefined;
                    const allViewModelIds = Array.from(this.viewModels.keys());
                    const currentIndex = allViewModelIds.indexOf(fluidItemId);

                    // å‰ã®ã‚¢ã‚¤ãƒ†ãƒ ã§Yjså‚ç…§ãŒã‚ã‚‹ã‚‚ã®ã‚’æ¢ã™
                    for (let i = currentIndex - 1; i >= 0; i--) {
                        const prevViewModel = this.viewModels.get(allViewModelIds[i]);
                        if (prevViewModel?.yjsRef) {
                            afterItemId = prevViewModel.yjsRef.yjsItemId;
                            console.log(`ğŸ”§ [OutlinerViewModel] Found previous Yjs item for positioning: ${afterItemId}`);
                            break;
                        }
                    }

                    // ã‚¿ã‚¤ãƒˆãƒ«ãƒãƒ¼ãƒ‰ã‚’æ¢ã—ã¦ãã®é…ä¸‹ã«é…ç½®
                    const rootItems = this.pageTreeManager.getRootItems();
                    const titleNode = rootItems.find(item => item.text === this.pageTitle);
                    const parentId = titleNode ? titleNode.id : undefined;

                    const yjsItemId = this.pageTreeManager.insertItem(
                        viewModel.text,
                        viewModel.author,
                        parentId, // parentId - ã‚¿ã‚¤ãƒˆãƒ«ãƒãƒ¼ãƒ‰é…ä¸‹
                        afterItemId, // afterItemId - å‰ã®ã‚¢ã‚¤ãƒ†ãƒ ã®å¾Œã«é…ç½®
                        fluidItemId // customItemId - Fluidã‚¢ã‚¤ãƒ†ãƒ IDã¨åŒã˜IDã‚’ä½¿ç”¨
                    );

                    // Yjså‚ç…§ã‚’è¨­å®š
                    viewModel.yjsRef = {
                        treeManager: this.pageTreeManager,
                        yjsItemId: yjsItemId,
                    };

                    console.log(`ğŸ”§ [OutlinerViewModel] âœ… Created new Yjs item: ${yjsItemId} for Fluid item: ${fluidItemId} after: ${afterItemId || 'start'}`);
                    return yjsItemId;
                } catch (createError) {
                    console.error(`ğŸ”§ [OutlinerViewModel] âŒ Failed to create Yjs item for ${fluidItemId}:`, createError);
                    return null;
                }
            }
        } catch (error) {
            console.warn(`ğŸ”§ [OutlinerViewModel] Error checking Yjs item ${fluidItemId}:`, error);
            return null;
        }
    }

    /**
     * Fluidã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°ã‚’Yjsã«åŒæœŸ
     * å¯¾å¿œã™ã‚‹Yjsã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’æ›´æ–°
     */
    async syncTextToYjs(fluidItemId: string, newText: string): Promise<void> {
        if (!this.pageTreeManager) {
            console.log(`ğŸ”§ [OutlinerViewModel] syncTextToYjs: TreeManager not available for ${fluidItemId}`);
            return;
        }

        const viewModel = this.viewModels.get(fluidItemId);
        if (!viewModel || !viewModel.yjsRef) {
            console.log(`ğŸ”§ [OutlinerViewModel] syncTextToYjs: No Yjs reference for ${fluidItemId}`);
            return;
        }

        try {
            this.pageTreeManager.updateItemText(viewModel.yjsRef.yjsItemId, newText);
            console.log(`ğŸ”§ [OutlinerViewModel] Updated Yjs item text: ${fluidItemId} -> "${newText}"`);
        } catch (error) {
            console.warn(`ğŸ”§ [OutlinerViewModel] Error updating Yjs item text ${fluidItemId}:`, error);
        }
    }

    /**
     * Fluidã‚¢ã‚¤ãƒ†ãƒ ã®Yjså‚ç…§ã‚’å–å¾—
     */
    getYjsReference(fluidItemId: string): YjsItemReference | null {
        const viewModel = this.viewModels.get(fluidItemId);
        return viewModel?.yjsRef || null;
    }

    /**
     * Yjsçµ±åˆã®å®Œäº†ã‚’å¾…æ©Ÿ
     */
    async waitForYjsIntegration(): Promise<void> {
        console.log("ğŸ”§ [OutlinerViewModel] Waiting for Yjs integration to complete...");

        // æœ€å¤§10ç§’é–“å¾…æ©Ÿ
        const maxWaitTime = 10000;
        const startTime = Date.now();

        while (Date.now() - startTime < maxWaitTime) {
            // ã™ã¹ã¦ã®Fluidã‚¢ã‚¤ãƒ†ãƒ ã«Yjså‚ç…§ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            let allItemsHaveYjsRef = true;
            let pendingItemsCount = 0;

            for (const [itemId, viewModel] of this.viewModels) {
                if (!viewModel.yjsRef) {
                    allItemsHaveYjsRef = false;
                    pendingItemsCount++;
                }
            }

            console.log(
                `ğŸ”§ [OutlinerViewModel] Integration status: ${
                    this.viewModels.size - pendingItemsCount
                }/${this.viewModels.size} items have Yjs references`,
            );

            if (allItemsHaveYjsRef) {
                console.log("ğŸ”§ [OutlinerViewModel] âœ… All items have Yjs references");
                break;
            }

            // 100mså¾…æ©Ÿã—ã¦ã‹ã‚‰å†ãƒã‚§ãƒƒã‚¯
            await new Promise(resolve => setTimeout(resolve, 100));
        }

        console.log("ğŸ”§ [OutlinerViewModel] Yjs integration completed");
    }

    /**
     * ãƒªã‚½ãƒ¼ã‚¹ã®è§£æ”¾
     */
    dispose(): void {
        this.viewModels.clear();
        this.visibleOrder = [];
        this.depthMap.clear();
        this.parentMap.clear();
        this.collapsedMap.clear();
        this.pageTreeManager = undefined;
    }
}
