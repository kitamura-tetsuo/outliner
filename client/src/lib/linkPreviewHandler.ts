/**
 * Module for handling link preview functionality
 *
 * This module provides functionality to display previews when hovering over internal links.
 * It works on link elements generated by ScrapboxFormatter.
 */

import type { Item } from "../schema/app-schema";
import { store } from "../stores/store.svelte";
import { getLogger } from "./logger";

const logger = getLogger("LinkPreviewHandler");

// Styles for the preview popup
const PREVIEW_STYLES = {
    position: "absolute",
    zIndex: "1000",
    width: "300px",
    maxHeight: "300px",
    backgroundColor: "white",
    border: "1px solid #ddd",
    borderRadius: "6px",
    boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
    padding: "12px",
    overflow: "hidden",
    fontSize: "14px",
};

// Currently displayed preview element
let currentPreview: HTMLElement | null = null;
// Timer for showing preview
let previewTimer: number | null = null;
// Timer for hiding preview
let hideTimer: number | null = null;

/**
 * Checks if a page exists
 * @param pageName Page name
 * @param projectName Project name (optional)
 * @returns true if the page exists
 */
export function pageExists(pageName: string, projectName?: string): boolean {
    // If a project is specified, check if it matches the current project
    if (projectName && store.project?.title !== projectName) {
        return false;
    }

    if (!store.pages?.current) return false;

    // Search for a page with a matching name
    for (const page of store.pages.current) {
        if (page.text.toLowerCase() === pageName.toLowerCase()) {
            return true;
        }
    }

    return false;
}

/**
 * Finds a page by its name
 * @param name Page name
 * @returns Page item, or null if not found
 */
function findPageByName(name: string): Item | null {
    if (!store.pages?.current) return null;

    // Search for a page with a matching name
    for (const page of store.pages.current) {
        if (page.text.toLowerCase() === name.toLowerCase()) {
            return page;
        }
    }

    return null;
}

/**
 * Generates preview content
 * @param pageName Page name
 * @param projectName Project name (optional)
 * @returns HTML element for preview
 */
function createPreviewContent(pageName: string, projectName?: string): HTMLElement {
    const previewElement = document.createElement("div");
    previewElement.className = "link-preview-popup";
    previewElement.setAttribute("role", "tooltip");

    // Apply styles
    Object.entries(PREVIEW_STYLES).forEach(([key, value]) => {
        previewElement.style[key as any] = value;
    });

    // Handle internal project links
    if (projectName) {
        // If different from current project, do not show preview
        if (projectName !== store.project?.title) {
            const errorDiv = document.createElement("div");
            errorDiv.style.color = "#d32f2f";
            errorDiv.textContent = "Cannot preview pages from other projects";
            previewElement.appendChild(errorDiv);
            return previewElement;
        }
    }

    // Search for the page
    const foundPage = findPageByName(pageName);
    if (foundPage) {
        // If page is found
        const contentDiv = document.createElement("div");

        // Title
        const titleElement = document.createElement("h3");
        titleElement.textContent = foundPage.text;
        titleElement.style.fontSize = "16px";
        titleElement.style.fontWeight = "600";
        titleElement.style.margin = "0 0 8px 0";
        titleElement.style.paddingBottom = "8px";
        titleElement.style.borderBottom = "1px solid #eee";
        titleElement.style.color = "#333";
        contentDiv.appendChild(titleElement);

        // List of items
        const itemsDiv = document.createElement("div");
        itemsDiv.style.maxHeight = "220px";
        itemsDiv.style.overflowY = "auto";

        if (foundPage.items && (foundPage.items as any).length > 0) {
            const ul = document.createElement("ul");
            ul.style.margin = "0";
            ul.style.padding = "0 0 0 20px";

            // Display up to 5 items
            const maxItems = Math.min(5, (foundPage.items as any).length);
            for (let i = 0; i < maxItems; i++) {
                const item = (foundPage.items as any)[i];
                if (item) {
                    const li = document.createElement("li");
                    li.textContent = item.text || "";
                    li.style.marginBottom = "4px";
                    li.style.color = "#555";
                    li.style.lineHeight = "1.4";
                    ul.appendChild(li);
                }
            }

            // Show "..." if there are more than 5 items
            if ((foundPage.items as any).length > 5) {
                const moreLi = document.createElement("li");
                moreLi.textContent = "...";
                moreLi.style.color = "#888";
                moreLi.style.fontStyle = "italic";
                ul.appendChild(moreLi);
            }

            itemsDiv.appendChild(ul);
        } else {
            // If there are no items
            const emptyP = document.createElement("p");
            emptyP.textContent = "This page has no content";
            emptyP.style.color = "#888";
            emptyP.style.fontStyle = "italic";
            emptyP.style.margin = "10px 0";
            itemsDiv.appendChild(emptyP);
        }

        contentDiv.appendChild(itemsDiv);
        previewElement.appendChild(contentDiv);
    } else {
        // If page is not found
        const notFoundDiv = document.createElement("div");
        notFoundDiv.style.color = "#d32f2f";
        notFoundDiv.style.display = "flex";
        notFoundDiv.style.flexDirection = "column";
        notFoundDiv.style.alignItems = "center";
        notFoundDiv.style.justifyContent = "center";
        notFoundDiv.style.minHeight = "100px";

        const notFoundP = document.createElement("p");
        notFoundP.textContent = "Page not found";
        notFoundDiv.appendChild(notFoundP);

        previewElement.appendChild(notFoundDiv);
    }

    return previewElement;
}

/**
 * Updates the preview position
 * @param previewElement Preview element
 * @param targetElement Target element (link)
 */
function updatePreviewPosition(previewElement: HTMLElement, targetElement: HTMLElement): void {
    const rect = targetElement.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    // Get preview width and height (use default values if not yet rendered)
    const previewWidth = previewElement.offsetWidth || 300;
    const previewHeight = previewElement.offsetHeight || 200;

    // Initial position (below the link)
    let top = rect.bottom + window.scrollY + 10;
    let left = rect.left + window.scrollX;

    // Adjust to left if it exceeds the right edge of the screen
    if (left + previewWidth > viewportWidth) {
        left = viewportWidth - previewWidth - 20;
    }

    // Show above if it exceeds the bottom edge of the screen
    if (top + previewHeight > viewportHeight + window.scrollY) {
        top = rect.top + window.scrollY - previewHeight - 10;
    }

    previewElement.style.top = `${top}px`;
    previewElement.style.left = `${left}px`;
}

/**
 * Handler for mouse enter event on a link
 * @param event Mouse event
 */
function handleLinkMouseEnter(event: MouseEvent): void {
    const target = event.target as HTMLElement;

    // Clear existing timer
    if (hideTimer !== null) {
        window.clearTimeout(hideTimer);
        hideTimer = null;
    }

    // Show preview with delay (prevent display when user accidentally hovers)
    previewTimer = window.setTimeout(() => {
        // Remove existing preview
        if (currentPreview) {
            document.body.removeChild(currentPreview);
            currentPreview = null;
        }

        // Get page name and project name from data attributes
        const pageName = target.dataset.page;
        const projectName = target.dataset.project;

        if (pageName) {
            // Create preview
            const previewElement = createPreviewContent(pageName, projectName);

            // Set preview position
            updatePreviewPosition(previewElement, target);

            // Add preview to DOM
            document.body.appendChild(previewElement);

            // Save current preview
            currentPreview = previewElement;

            // Set mouse events for preview element as well
            previewElement.addEventListener("mouseenter", () => {
                // Clear hide timer if mouse is over the preview
                if (hideTimer !== null) {
                    window.clearTimeout(hideTimer);
                    hideTimer = null;
                }
            });

            previewElement.addEventListener("mouseleave", () => {
                // Hide if mouse leaves the preview
                hidePreview();
            });
        }
    }, 300); // 300ms delay
}

/**
 * Handler for mouse leave event on a link
 */
function handleLinkMouseLeave(): void {
    // Clear display timer
    if (previewTimer !== null) {
        window.clearTimeout(previewTimer);
        previewTimer = null;
    }

    // Hide with delay (allow time for user to move to preview)
    hideTimer = window.setTimeout(() => {
        hidePreview();
    }, 200); // 200ms delay
}

/**
 * Hides the preview
 */
function hidePreview(): void {
    if (currentPreview) {
        document.body.removeChild(currentPreview);
        currentPreview = null;
    }
}

// Instance of MutationObserver
let observer: MutationObserver | null = null;

/**
 * Sets event listeners for internal links on the specified element
 * @param element Element to set event listeners on
 */
function addLinkEventListeners(element: Element): void {
    // Flag to check if already set
    const hasListeners = element.getAttribute("data-link-listeners") === "true";

    if (!hasListeners) {
        element.addEventListener("mouseenter", handleLinkMouseEnter as EventListener);
        element.addEventListener("mouseleave", handleLinkMouseLeave as EventListener);

        // Set flag indicating listeners are set
        element.setAttribute("data-link-listeners", "true");

        logger.debug(`Link preview handlers added to ${element.textContent}`);
    }
}

/**
 * Sets event listeners for internal links in the page
 * This function must be called after the page loads
 */
export function setupLinkPreviewHandlers(): void {
    try {
        // Get internal links
        const internalLinks = document.querySelectorAll(".internal-link");

        // Set event listeners for each link
        internalLinks.forEach(link => {
            addLinkEventListeners(link);
        });

        // Set MutationObserver (if not already set)
        if (!observer) {
            setupMutationObserver();
        }

        logger.info(`Link preview handlers set up for ${internalLinks.length} links`);
    } catch (error) {
        const err = error instanceof Error ? error : new Error(String(error));
        logger.error({ err }, "Error setting up link preview handlers");
    }
}

/**
 * Sets up MutationObserver to monitor DOM changes
 */
function setupMutationObserver(): void {
    try {
        // Cleanup existing Observer
        if (observer) {
            observer.disconnect();
        }

        // Create new Observer
        observer = new MutationObserver(mutations => {
            let newLinksFound = false;

            // Handle each change
            mutations.forEach(mutation => {
                // Handle added nodes
                if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
                    mutation.addedNodes.forEach(node => {
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            // Search for internal links within added element
                            const element = node as Element;

                            // Check if the added element itself is an internal link
                            if (element.classList && element.classList.contains("internal-link")) {
                                addLinkEventListeners(element);
                                newLinksFound = true;
                            }

                            // Search for internal links within added element
                            const links = element.querySelectorAll(".internal-link");
                            if (links.length > 0) {
                                links.forEach(link => {
                                    addLinkEventListeners(link);
                                });
                                newLinksFound = true;
                            }
                        }
                    });
                }

                // Handle attribute changes (e.g., when class changes)
                if (
                    mutation.type === "attributes"
                    && mutation.attributeName === "class"
                    && mutation.target.nodeType === Node.ELEMENT_NODE
                ) {
                    const element = mutation.target as Element;
                    if (element.classList && element.classList.contains("internal-link")) {
                        addLinkEventListeners(element);
                        newLinksFound = true;
                    }
                }
            });

            if (newLinksFound) {
                logger.debug("New internal links found and handlers added");
            }
        });

        // Start observing
        observer.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ["class"],
        });

        logger.info("MutationObserver for link preview handlers set up");
    } catch (error) {
        const err = error instanceof Error ? error : new Error(String(error));
        logger.error({ err }, "Error setting up MutationObserver");
    }
}

// Cleanup previews on page transition
export function cleanupLinkPreviews(): void {
    // Cleanup preview element
    if (currentPreview) {
        document.body.removeChild(currentPreview);
        currentPreview = null;
    }

    // Cleanup timers
    if (previewTimer !== null) {
        window.clearTimeout(previewTimer);
        previewTimer = null;
    }

    if (hideTimer !== null) {
        window.clearTimeout(hideTimer);
        hideTimer = null;
    }

    // Cleanup MutationObserver
    if (observer) {
        observer.disconnect();
        observer = null;
        logger.info("MutationObserver for link preview handlers cleaned up");
    }
}
