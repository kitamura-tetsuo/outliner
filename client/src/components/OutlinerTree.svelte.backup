<script lang="ts">
import { goto } from "$app/navigation";
import { Tree } from "fluid-framework";
import {
    onDestroy,
    onMount,
} from "svelte";
import { getLogger } from "../lib/logger";
import { YjsProjectManager } from "../lib/yjsProjectManager.svelte";
// dataOperationHooks import removed (no longer used for realtime validation)
import {
    Item,
    Items,
} from "../schema/app-schema";
import { editorOverlayStore } from "../stores/EditorOverlayStore.svelte";
import { fluidStore } from "../stores/fluidStore.svelte";
import type { DisplayItem } from "../stores/OutlinerViewModel";
import { OutlinerViewModel } from "../stores/OutlinerViewModel";
import { TreeSubscriber } from "../stores/TreeSubscriber";
import EditorOverlay from "./EditorOverlay.svelte";
import OutlinerItem from "./OutlinerItem.svelte";

const logger = getLogger();

/**
 * ã€é‡è¦ãªå®Ÿè£…ãƒ¡ãƒ¢ã€‘
 * ã“ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§ã¯Fluid Frameworkã¨Svelteã®ã€Œãƒã‚¸ã‚«ãƒ«ãªé€£æºã€ã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã™ã€‚
 * ç‰¹ã«ã‚¿ã‚¤ãƒˆãƒ«ç·¨é›†ã§ã¯ã€Svelteã®UI (bind:value) ãŒç›´æ¥Fluidã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (pageItem.text) ã«
 * ãƒã‚¤ãƒ³ãƒ‰ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šä¸­é–“å¤‰æ•°ã‚„TreeSubscriberãªã—ã§åŒæ–¹å‘ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãŒå®Ÿç¾ã•ã‚Œã¦ã„ã¾ã™ã€‚
 *
 * ã“ã®æ–¹æ³•ãŒæ©Ÿèƒ½ã™ã‚‹ç†ç”±ï¼š
 * 1. Fluid Frameworkã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ—ãƒ­ã‚­ã‚·ãƒ™ãƒ¼ã‚¹ã§ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å¤‰æ›´ã‚’æ¤œçŸ¥
 * 2. Svelteã®åŒæ–¹å‘ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãŒãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¸ã®æ›¸ãè¾¼ã¿ã‚’å‡¦ç†
 * 3. FluidãŒè‡ªå‹•çš„ã«å¤‰æ›´ã‚’åˆ†æ•£ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«ã«åŒæœŸ
 *
 * æ³¨æ„: ã“ã®é€£æºãŒå£Šã‚ŒãŸå ´åˆã¯ã€æ˜ç¤ºçš„ãªTreeSubscriberã¨æ›´æ–°é–¢æ•°ã®ä½¿ç”¨ã«æˆ»ã™ã“ã¨ã‚’æ¤œè¨ã—ã¦ãã ã•ã„
 */

interface Props {
    pageItem: Item; // ãƒšãƒ¼ã‚¸ã¨ã—ã¦è¡¨ç¤ºã™ã‚‹ Item
    projectName: string;
    pageName: string;
    isReadOnly?: boolean;
    onEdit?: () => void;
}

let { pageItem, projectName, pageName, isReadOnly = false, onEdit }: Props = $props();

let currentUser = $derived(fluidStore.currentUser?.id ?? 'anonymous');

// ãƒ“ãƒ¥ãƒ¼ã‚¹ãƒˆã‚¢ã‚’ä½œæˆ
const viewModel = new OutlinerViewModel();

// ã‚³ãƒ³ãƒ†ãƒŠè¦ç´ ã¸ã®å‚ç…§
let containerRef: HTMLDivElement;


let itemHeights = $state<number[]>([]);
let itemPositions = $state<number[]>([]);

// ãƒ‰ãƒ©ãƒƒã‚°é¸æŠé–¢é€£ã®çŠ¶æ…‹
let isDragging = $state(false);
let dragStartItemId = $state<string | null>(null);
let dragStartOffset = $state(0);
let dragCurrentItemId = $state<string | null>(null);
let dragCurrentOffset = $state(0);

// ç„¡é™ãƒ«ãƒ¼ãƒ—ã‚’é˜²ããŸã‚ã®ãƒ•ãƒ©ã‚°
let isUpdatingDisplayItems = false;
let lastUpdateTime = 0;
let lastItemsLength = -1;

// è¤‡æ•°ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç›£è¦–ã™ã‚‹ãŸã‚ã«ã€TreeSubscriberã‚’æ‹¡å¼µ
const displayItems = new TreeSubscriber<Items, DisplayItem[]>(
    pageItem.items as Items,
    "treeChanged",
    () => {
        const currentTime = Date.now();
        const currentItemsLength = (pageItem.items as any)?.length || 0;

        // ç„¡é™ãƒ«ãƒ¼ãƒ—ã‚’é˜²ã - çŸ­æ™‚é–“ã§ã®é€£ç¶šå®Ÿè¡Œã‚’ãƒ–ãƒ­ãƒƒã‚¯
        if (isUpdatingDisplayItems) {
            return viewModel.getVisibleItems();
        }

        // åŒã˜çŠ¶æ…‹ã§ã®é€£ç¶šå®Ÿè¡Œã‚’ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆ100msä»¥å†…ã§åŒã˜lengthã®å ´åˆï¼‰
        if (currentTime - lastUpdateTime < 100 && currentItemsLength === lastItemsLength) {
            return viewModel.getVisibleItems();
        }

        try {
            isUpdatingDisplayItems = true;
            lastUpdateTime = currentTime;
            lastItemsLength = currentItemsLength;

            // pageItem.itemsãŒç©ºã®å ´åˆã€æ—¢å­˜ã®viewModelã®çŠ¶æ…‹ã‚’ä¿æŒ
            if (currentItemsLength === 0) {
                const existingItems = viewModel.getVisibleItems();
                if (existingItems.length > 0) {
                    return existingItems;
                }
            }

            viewModel.updateFromModel(pageItem);
            const visibleItems = viewModel.getVisibleItems();

            return visibleItems;
        } finally {
            // éåŒæœŸã§ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆDOMæ›´æ–°å®Œäº†å¾Œï¼‰
            setTimeout(() => {
                isUpdatingDisplayItems = false;
            }, 0);
        }
    },
);

// nodeChangedã‚¤ãƒ™ãƒ³ãƒˆã‚‚ç›£è¦–ã—ã¦ã‚³ãƒ¡ãƒ³ãƒˆå¤‰æ›´ã‚’æ¤œå‡º
const nodeChangedSubscriber = new TreeSubscriber<Item, boolean>(
    pageItem,
    "nodeChanged",
    () => {
        // nodeChangedã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç”Ÿã—ãŸæ™‚ã«ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ‡ãƒ«ã‚’æ›´æ–°
        // ãŸã ã—ã€ç„¡é™ãƒ«ãƒ¼ãƒ—ã‚’é˜²ããŸã‚ã«çŸ­æ™‚é–“ã§ã®é€£ç¶šå®Ÿè¡Œã‚’ãƒ–ãƒ­ãƒƒã‚¯
        const currentTime = Date.now();
        if (currentTime - lastUpdateTime < 50) {
            return false;
        }

        if (!isUpdatingDisplayItems) {
            try {
                isUpdatingDisplayItems = true;
                lastUpdateTime = currentTime;
                viewModel.updateFromModel(pageItem);
                return true;
            } finally {
                setTimeout(() => {
                    isUpdatingDisplayItems = false;
                }, 0);
            }
        }
        return false;
    },
);

// nodeChangedSubscriberã‚’å‚ç…§ã—ã¦ã‚¤ãƒ™ãƒ³ãƒˆç›£è¦–ã‚’æœ‰åŠ¹åŒ–
$effect(() => {
    // nodeChangedSubscriberã®å€¤ã‚’å‚ç…§ã™ã‚‹ã“ã¨ã§ç›£è¦–ã‚’æœ‰åŠ¹åŒ–
    nodeChangedSubscriber.current;
});

// ã‚¢ã‚¤ãƒ†ãƒ ã®é«˜ã•ãŒå¤‰æ›´ã•ã‚ŒãŸã¨ãã«ä½ç½®ã‚’å†è¨ˆç®—
function updateItemPositions() {
    let currentTop = 8; // æœ€åˆã®ã‚¢ã‚¤ãƒ†ãƒ ã®ä¸Šéƒ¨ãƒãƒ¼ã‚¸ãƒ³
    itemPositions = itemHeights.map((height) => {
        const position = currentTop;
        // æœ€å°é«˜ã•36pxã‚’è€ƒæ…®
        const effectiveHeight = Math.max(height || 28, 28);
        // ãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ«ã®å¾Œã¯24pxã€ãã‚Œä»¥é™ã¯36pxã®é–“éš”
        currentTop += effectiveHeight;
        return position;
    });

    // ãƒ‡ãƒãƒƒã‚°ç”¨ã®ãƒ­ã‚°
    if (typeof window !== "undefined" && (window as any).DEBUG_MODE) {
        console.log("Heights:", $state.snapshot(itemHeights));
        console.log("Positions:", $state.snapshot(itemPositions));
    }
}

// ã‚¢ã‚¤ãƒ†ãƒ ã®é«˜ã•ãŒå¤‰æ›´ã•ã‚ŒãŸã¨ãã®ãƒãƒ³ãƒ‰ãƒ©
function handleItemResize(event: CustomEvent) {
    const { index, height } = event.detail;
    if (typeof index === 'number' && typeof height === 'number') {
        // é«˜ã•ãŒå®Ÿéš›ã«å¤‰æ›´ã•ã‚Œã€ã‹ã¤0ã‚ˆã‚Šå¤§ãã„å ´åˆã®ã¿æ›´æ–°
        if (itemHeights[index] !== height && height > 0) {
            itemHeights[index] = height;
            updateItemPositions();

            // ãƒ‡ãƒãƒƒã‚°ç”¨ã®ãƒ­ã‚°
            if (typeof window !== "undefined" && (window as any).DEBUG_MODE) {
                console.log(`Item ${index} height changed to ${height}px`);
            }
        }
    }
}

onMount(async () => {
    const client = fluidStore.fluidClient;
    if (client?.currentUser) {
        currentUser = client.currentUser.id;
    }

    // onEdit ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ã‚¹ãƒˆã‚¢ã«è¨­å®š
    editorOverlayStore.setOnEditCallback(handleEdit);

    // OutlinerViewModelã‚’ã‚¹ãƒˆã‚¢ã«è¨­å®š
    editorOverlayStore.setOutlinerViewModel(viewModel);

    // OutlinerViewModelã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«å…¬é–‹ï¼ˆYjsçµ±åˆç”¨ï¼‰
    if (typeof window !== "undefined") {
        (window as any).__OUTLINER_VIEW_MODEL__ = viewModel;
        // ç¾åœ¨ã®ãƒšãƒ¼ã‚¸IDã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«è¨­å®šï¼ˆYjsçµ±åˆç”¨ï¼‰
        (window as any).__CURRENT_PAGE_ID__ = pageItem?.id;
        console.log(`ğŸ”§ [OutlinerTree] Current page ID set to global: ${pageItem?.id}`);

        // Enterãªã©ã«ã‚ˆã‚ŠCursor.tsãŒç™ºç«ã™ã‚‹navigate-to-itemã‚’å—ã‘å–ã‚Šã€Yjsåæ˜ ã‚’è£œåŠ©
        const navHandler = (e: Event) => {
            const ev = e as CustomEvent;
            if (!ev?.detail) return;
            handleNavigateToItem(ev);
        };
        document.addEventListener("navigate-to-item", navHandler as EventListener);
        // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ç”¨ã«ä¿æŒ
        (window as any).__OUTLINER_NAV_HANDLER__ = navHandler;
    }

    // åˆæœŸçŠ¶æ…‹ã§ã‚¢ã‚¤ãƒ†ãƒ ã®é«˜ã•ã‚’åˆæœŸåŒ–
    itemHeights = new Array(displayItems.current.length).fill(0);

    // å„ã‚¢ã‚¤ãƒ†ãƒ ã®åˆæœŸé«˜ã•ã‚’å–å¾—ã—ã¦è¨­å®š
    requestAnimationFrame(() => {
        const items = document.querySelectorAll('.item-container');
        items.forEach((item, index) => {
            const height = item.getBoundingClientRect().height;
            itemHeights[index] = height;
        });
        updateItemPositions();
    });

    // Yjsçµ±åˆã¯å‰Šé™¤ï¼ˆãƒ¢ãƒ¼ãƒ‰åˆ†é›¢ã®ãŸã‚ï¼‰
    // å„ãƒ¢ãƒ¼ãƒ‰ã§ç‹¬ç«‹ã—ãŸãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã¿ä½¿ç”¨
    logger.info("Yjs integration disabled for mode separation");
});

// displayItemsãŒå¤‰æ›´ã•ã‚ŒãŸã¨ãã«itemHeightsã‚’æ›´æ–°
$effect(() => {
    const itemCount = displayItems.current.length;
    if (itemHeights.length !== itemCount) {
        // æ—¢å­˜ã®ã‚¢ã‚¤ãƒ†ãƒ ã®é«˜ã•ã‚’ä¿æŒã—ã¤ã¤ã€æ–°ã—ã„é…åˆ—ã‚’ä½œæˆ
        const newHeights = new Array(itemCount).fill(28); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¨ã—ã¦28pxã‚’è¨­å®š
        itemHeights.forEach((height, index) => {
            if (index < itemCount) {
                newHeights[index] = height || 28; // 0ã®å ´åˆã¯28pxã‚’ä½¿ç”¨
            }
        });
        itemHeights = newHeights;

        // DOMã®æ›´æ–°ã‚’å¾…ã£ã¦ã‹ã‚‰å®Ÿéš›ã®é«˜ã•ã‚’å–å¾—
        requestAnimationFrame(() => {
            const items = document.querySelectorAll('.item-container');
            items.forEach((item, index) => {
                const height = item.getBoundingClientRect().height;
                if (height > 0) {  // å®Ÿéš›ã®é«˜ã•ãŒå–å¾—ã§ããŸå ´åˆã®ã¿æ›´æ–°
                    itemHeights[index] = height;
                }
            });
            updateItemPositions();
        });
    }
});

onDestroy(() => {
    // onEdit ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ã‚¯ãƒªã‚¢
    editorOverlayStore.setOnEditCallback(null);

    // navigate-to-item ãƒªã‚¹ãƒŠãƒ¼ã‚’è§£é™¤
    if (typeof window !== "undefined") {
        const navHandler = (window as any).__OUTLINER_NAV_HANDLER__;
        if (navHandler) {
            document.removeEventListener("navigate-to-item", navHandler as EventListener);
            (window as any).__OUTLINER_NAV_HANDLER__ = null;
        }
    }

    // ãƒªã‚½ãƒ¼ã‚¹ã‚’è§£æ”¾
    viewModel.dispose();
});

async function handleAddItem() {
    console.log("ğŸ”§ [OutlinerTree] handleAddItem called");

    // ãƒ¢ãƒ¼ãƒ‰åˆ¤å®š
    const mode = (typeof window !== "undefined") ? localStorage.getItem("OUTLINER_MODE") : null;
    const isYjsMode = mode === "yjs";

    console.log("ğŸ”§ [OutlinerTree] Mode debug:", {
        mode,
        isYjsMode,
        hasYjsProjectManager: !!(window as any).__YJS_PROJECT_MANAGER__,
        hasFluidClient: !!(window as any).__FLUID_CLIENT__,
    });

    console.log(`ğŸ”§ [OutlinerTree] Current mode: ${mode || 'fluid'}`);

    if (isYjsMode) {
        // Yjsãƒ¢ãƒ¼ãƒ‰: Yjsã‚¢ã‚¤ãƒ†ãƒ ã®ã¿ä½œæˆ
        console.log("ğŸ”§ [OutlinerTree] Adding Yjs item (Yjs mode)...");

        try {
            const ypm = (window as any).__YJS_PROJECT_MANAGER__;
            console.log(`ğŸ”§ [OutlinerTree] YjsProjectManager debug:`, {
                exists: !!ypm,
                hasGetPages: ypm && typeof ypm.getPages === 'function',
                hasAddItemToPage: ypm && typeof ypm.addItemToPage === 'function',
                pageName: pageName,
            });

            if (ypm && typeof ypm.getPages === 'function') {
                const pages = ypm.getPages();
                console.log(`ğŸ”§ [OutlinerTree] Available Yjs pages:`, pages.map((p:any) => ({ id: p.id, title: p.title })));

                const targetPage = pages.find((p:any) => String(p.title||'') === pageName) || pages[0];
                const yPageId = targetPage?.id;
                const itemText = ""; // æ–°è¦ã‚¢ã‚¤ãƒ†ãƒ ã¯ç©ºãƒ†ã‚­ã‚¹ãƒˆã§é–‹å§‹
                const author = String((currentUser as any)?.name || currentUser || "local");

                console.log(`ğŸ”§ [OutlinerTree] Target page:`, { id: yPageId, title: targetPage?.title, pageName });

                if (yPageId) {
                    console.log(`ğŸ”§ [OutlinerTree] Creating Yjs item for yPage ${yPageId}: "${itemText}"`);
                    const yjsItemId = await ypm.addItemToPage(yPageId, itemText, author);
                    if (yjsItemId) {
                        console.log(`ğŸ”§ [OutlinerTree] âœ… Yjs item created: ${yjsItemId} for "${itemText}"`);

                        // Yjsãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€Fluidãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ä¾å­˜ã—ãªã„
                        // UIã®æ›´æ–°ã¯ã€Yjsãƒ‡ãƒ¼ã‚¿ã®å¤‰æ›´ã«ã‚ˆã£ã¦è‡ªå‹•çš„ã«åæ˜ ã•ã‚Œã‚‹
                        console.log(`ğŸ”§ [OutlinerTree] âœ… Yjs item created in pure Yjs mode: ${yjsItemId}`);

                        // UIæ›´æ–°ã®ãŸã‚ã«Yjsãƒ‡ãƒ¼ã‚¿ã®å¤‰æ›´ã‚’é€šçŸ¥
                        // ã“ã‚Œã«ã‚ˆã‚Šã€Yjsãƒ™ãƒ¼ã‚¹ã®UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒæ›´æ–°ã•ã‚Œã‚‹
                        if (typeof window !== "undefined" && (window as any).__YJS_UI_UPDATE_CALLBACK__) {
                            (window as any).__YJS_UI_UPDATE_CALLBACK__();
                        }

                        // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿ä¸€è‡´ãƒã‚§ãƒƒã‚¯ã¯å‰Šé™¤ï¼ˆJSONã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆæ¯”è¼ƒã®ã¿ä½¿ç”¨ï¼‰
                    } else {
                        console.warn(`ğŸ”§ [OutlinerTree] âŒ Failed to create Yjs item for "${itemText}"`);
                    }
                } else {
                    console.warn(`ğŸ”§ [OutlinerTree] Could not resolve Yjs pageId for pageName="${pageName}"`);
                    console.warn(`ğŸ”§ [OutlinerTree] Available pages:`, pages);
                }
            } else {
                console.warn(`ğŸ”§ [OutlinerTree] YjsProjectManager not available for item creation`);
                console.warn(`ğŸ”§ [OutlinerTree] YjsProjectManager state:`, {
                    exists: !!ypm,
                    type: typeof ypm,
                    methods: ypm ? Object.getOwnPropertyNames(ypm) : [],
                });
            }
        } catch (yjsError) {
            console.error(`ğŸ”§ [OutlinerTree] Error creating Yjs item:`, yjsError);
        }
    } else {
        // Fluidãƒ¢ãƒ¼ãƒ‰: Fluidã‚¢ã‚¤ãƒ†ãƒ ã‚’ä½œæˆã—ã€ä¸¦è¡Œã—ã¦Yjsã‚¢ã‚¤ãƒ†ãƒ ã‚‚ä½œæˆ
        if (pageItem && !isReadOnly && pageItem.items && Tree.is(pageItem.items, Items)) {
            console.log("ğŸ”§ [OutlinerTree] Adding Fluid item (Fluid mode)...");

            // Fluidã‚¢ã‚¤ãƒ†ãƒ è¿½åŠ 
            const newItem = pageItem.items.addNode(currentUser);

            console.log(`ğŸ”§ [OutlinerTree] Fluid item created: ${newItem?.id} with text: "${newItem?.text}"`);

            // å°‘ã—å¾…æ©Ÿã—ã¦OutlinerViewModelãŒæ›´æ–°ã•ã‚Œã‚‹ã®ã‚’å¾…ã¤
            await new Promise(resolve => setTimeout(resolve, 100));

            if (newItem) {
                logger.info(`Fluid item added: "${newItem.text}" to page: ${pageItem.text}`);
                console.log(`ğŸ”§ [OutlinerTree] Fluid item created: ${newItem.id} for "${newItem.text}"`);

                // Fluidãƒ¢ãƒ¼ãƒ‰ã§ã‚‚ã€ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆæ¯”è¼ƒã®ãŸã‚ã«Yjsã‚¢ã‚¤ãƒ†ãƒ ã‚‚ä½œæˆ
                try {
                    const yjsProjectManager = (window as any).__YJS_PROJECT_MANAGER__;
                    if (yjsProjectManager) {
                        const pageId = generalStore.currentPage?.id;
                        if (pageId) {
                            const itemText = newItem.text as string;
                            const author = (currentUser as any)?.name || "test-user";

                            console.log(`ğŸ”§ [OutlinerTree] Creating parallel Yjs item for page ${pageId}: "${itemText}" with ID ${newItem.id}`);
                            const yjsItemId = await yjsProjectManager.addItemToPage(pageId, itemText, author, undefined, newItem.id);
                            if (yjsItemId) {
                                console.log(`ğŸ”§ [OutlinerTree] âœ… Parallel Yjs item created: ${yjsItemId} for "${itemText}"`);
                            } else {
                                console.warn(`ğŸ”§ [OutlinerTree] âŒ Failed to create parallel Yjs item for "${itemText}"`);
                            }
                        }
                    }
                } catch (error) {
                    console.warn(`ğŸ”§ [OutlinerTree] âš ï¸ Error creating parallel Yjs item:`, error);
                }

                // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿ä¸€è‡´ãƒã‚§ãƒƒã‚¯ã¯å‰Šé™¤ï¼ˆJSONã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆæ¯”è¼ƒã®ã¿ä½¿ç”¨ï¼‰
            } else {
                logger.warn('Cannot add item: New Fluid item not created');
                console.warn('ğŸ”§ [OutlinerTree] âŒ New Fluid item not created');
            }
        } else {
            console.log("ğŸ”§ [OutlinerTree] Cannot add item - conditions not met");
        }
    }
}

// æœ€ä¸‹éƒ¨ã®ã‚¢ã‚¤ãƒ†ãƒ ç·¨é›†ä¸­ã«ç©ºã®å…„å¼Ÿã‚¢ã‚¤ãƒ†ãƒ ã‚’è¿½åŠ 
let lastHandleEditTime = 0;
let lastHandleEditText = "";

async function handleEdit() {
    console.log("ğŸ”§ [OutlinerTree] handleEdit called");

    // å¤–éƒ¨ã®onEditãŒã‚ã‚Œã°å‘¼ã³å‡ºã—
    if (onEdit) onEdit();



    // è¡¨ç¤ºã‚¢ã‚¤ãƒ†ãƒ ã®æœ€å¾Œã‚’å–å¾—
    const items = displayItems.current;
    if (items.length === 0) return;
    const last = items[items.length - 1];
    const activeId = editorOverlayStore.getActiveItem();
    if (!activeId || activeId !== last.model.id) return;

    // æœ€ä¸‹éƒ¨ã‚¢ã‚¤ãƒ†ãƒ ãŒç©ºã§ãªã„å ´åˆã®ã¿è¿½åŠ 
    const currentText = (last.model.original.text as string) || "";
    if (currentText.trim().length === 0) return;

    // ã‚ˆã‚Šå³æ ¼ãªãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç†ï¼šçŸ­æ™‚é–“å†…ã®é€£ç¶šå‘¼ã³å‡ºã—ã‚’ä¸€å¾‹ã«é˜²ãï¼ˆãƒ†ã‚­ã‚¹ãƒˆå¤‰åŒ–æœ‰ç„¡ã‚’å•ã‚ãšï¼‰
    const now = Date.now();
    if (now - lastHandleEditTime < 800) {
        console.log("ğŸ”§ [OutlinerTree] handleEdit debounced (within 800ms)");
        return;
    }

    // è¿½åŠ ã®æ¡ä»¶ï¼šæœ€ä¸‹éƒ¨ã‚¢ã‚¤ãƒ†ãƒ ã®æ¬¡ã«ã™ã§ã«ç©ºã®ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚ã‚‹å ´åˆã¯è¿½åŠ ã—ãªã„
    const nextItems = displayItems.current.slice(displayItems.current.length - 1);
    if (nextItems.length > 1) {
        const nextItem = nextItems[1];
        const nextText = (nextItem?.model?.original?.text as string) || "";
        if (nextText.trim().length === 0) {
            console.log("ğŸ”§ [OutlinerTree] handleEdit skipped - empty item already exists after current item");
            return;
        }
    }

    // æœ€å¾Œã®ã‚¢ã‚¤ãƒ†ãƒ ã®å¾Œã«æ—¢ã«ç©ºã®ã‚¢ã‚¤ãƒ†ãƒ ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    const allItems = displayItems.current;
    const lastIndex = allItems.findIndex(item => item.model.id === last.model.id);
    if (lastIndex >= 0 && lastIndex < allItems.length - 1) {
        const nextItem = allItems[lastIndex + 1];
        const nextText = (nextItem?.model?.original?.text as string) || "";
        if (nextText.trim().length === 0) {
            console.log("ğŸ”§ [OutlinerTree] handleEdit skipped - empty item already exists at next position");
            return;
        }
    }

    lastHandleEditTime = now;
    lastHandleEditText = currentText;

    console.log("ğŸ”§ [OutlinerTree] Adding new item via handleEdit");

    let newItem: Item | null = null;
    const parent = Tree.parent(last.model.original);
    if (parent && Tree.is(parent, Items)) {
        const idx = parent.indexOf(last.model.original);
        newItem = parent.addNode(currentUser, idx + 1);
    } else if (pageItem.items && Tree.is(pageItem.items, Items)) {
        const idx = pageItem.items.indexOf(last.model.original);
        newItem = pageItem.items.addNode(currentUser, idx + 1);
    }

    if (newItem) {
        console.log(`ğŸ”§ [OutlinerTree] Fluid item processed via handleEdit: ${newItem.id}`);

        // ä¸¦è¡Œå‡¦ç†ã¯å‰Šé™¤ï¼ˆãƒ¢ãƒ¼ãƒ‰åˆ†é›¢ã®ãŸã‚ï¼‰
        // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿ä¸€è‡´ãƒã‚§ãƒƒã‚¯ã¯å‰Šé™¤ï¼ˆJSONã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆæ¯”è¼ƒã®ã¿ä½¿ç”¨ï¼‰
        console.log(`ğŸ”§ [OutlinerTree] Fluid item created via handleEdit (no parallel processing)`);
    }
}

function handleToggleCollapse(event: CustomEvent) {
    const { itemId } = event.detail;

    // æŠ˜ã‚ŠãŸãŸã¿çŠ¶æ…‹ã‚’å¤‰æ›´
    viewModel.toggleCollapsed(itemId);
}

function handleIndent(event: CustomEvent) {
    // ãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ«ã®å ´åˆã¯ç„¡è¦–
    if (event.detail.itemId === "page-title") return;

    // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’å¢—ã‚„ã™å‡¦ç†
    const { itemId } = event.detail;

    // å…ƒã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
    const itemViewModel = viewModel.getViewModel(itemId);
    if (!itemViewModel) return;

    const item = itemViewModel.original;

    logger.info(`Indent event received for item: ${item.id}`);

    // 1. ã‚¢ã‚¤ãƒ†ãƒ ã®è¦ªã‚’å–å¾—
    const parent = Tree.parent(item);
    if (!Tree.is(parent, Items)) return;

    // 2. è¦ªå†…ã§ã®ã‚¢ã‚¤ãƒ†ãƒ ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
    const index = parent.indexOf(item);
    if (index <= 0) return; // æœ€åˆã®ã‚¢ã‚¤ãƒ†ãƒ ã¯ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã§ããªã„

    // 3. å‰ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
    const previousItem = parent[index - 1];

    try {
        // 4. å‰ã®ã‚¢ã‚¤ãƒ†ãƒ ã®å­ãƒªã‚¹ãƒˆã¸ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç§»å‹•
        // itemIndexãŒç¢ºå®Ÿã«å–å¾—ã§ãã‚‹ã‚ˆã†ã«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å†è¨ˆç®—
        const itemIndex = parent.indexOf(item);

        // ç§»å‹•æ“ä½œã®å‰ã«ãƒ­ã‚°ã‚’è¿½åŠ 
        logger.info(
            `Moving item from parent (${parent.length} items) at index ${itemIndex} to previous item's children`,
        );

        // å³å¯†ãªãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ã‚’è¡Œã†
        const prevItems = previousItem.items;
        if (prevItems && Tree.is(prevItems, Items)) {
            Tree.runTransaction(parent, () => {
                // å‹ã‚­ãƒ£ã‚¹ãƒˆã‚’ä½¿ç”¨ã—ã¦TypeScriptã‚¨ãƒ©ãƒ¼ã‚’å›é¿
                (prevItems as any).moveRangeToEnd(itemIndex, itemIndex + 1, parent);
            });

            logger.info(`Indented item under previous item`);
        }
    }
    catch (error) {
        console.error("Failed to indent item:", error);
    }
}

function handleUnindent(event: CustomEvent) {
    // ãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ«ã®å ´åˆã¯ç„¡è¦–
    if (event.detail.itemId === "page-title") return;

    // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™å‡¦ç†
    const { itemId } = event.detail;

    // å…ƒã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
    const itemViewModel = viewModel.getViewModel(itemId);
    if (!itemViewModel) return;

    const item = itemViewModel.original;

    logger.info(`Unindent event received for item: ${item.id}`);

    // 1. ã‚¢ã‚¤ãƒ†ãƒ ã®è¦ªã‚’å–å¾—
    const parentList = Tree.parent(item);
    if (!Tree.is(parentList, Items)) return;

    // 2. è¦ªã®è¦ªã‚’å–å¾—ï¼ˆè¦ªã‚°ãƒ«ãƒ¼ãƒ—ã‚’å–å¾—ï¼‰
    const parentItem = Tree.parent(parentList);
    if (!parentItem || !Tree.is(parentItem, Item)) return; // ãƒ«ãƒ¼ãƒˆã‚¢ã‚¤ãƒ†ãƒ ã®ç›´ä¸‹ã¯æ—¢ã«æœ€ä¸Šä½

    const grandParentList = Tree.parent(parentItem);
    if (!grandParentList || !Tree.is(grandParentList, Items)) return; // ãƒ«ãƒ¼ãƒˆã‚¢ã‚¤ãƒ†ãƒ ã®ç›´ä¸‹ã¯æ—¢ã«æœ€ä¸Šä½

    try {
        // 3. è¦ªã‚¢ã‚¤ãƒ†ãƒ ã®indexå–å¾—
        const parentIndex = grandParentList.indexOf(parentItem);

        // 4. è¦ªã®è¦ªã®ã€è¦ªã®æ¬¡ã®ä½ç½®ã«ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç§»å‹•
        const itemIndex = parentList.indexOf(item);

        // parentListã®è¦ç´ ã‚’grandParentListã«ç§»å‹•
        const sourceItem = parentList[itemIndex];
        if (sourceItem) {
            // readonly arrayå‹ã«é©åˆã™ã‚‹ã‚ˆã†ã‚³ãƒ”ãƒ¼
            const targetArray = grandParentList as any;

            Tree.runTransaction(grandParentList, () => {
                targetArray.moveRangeToIndex(parentIndex + 1, itemIndex, itemIndex + 1, parentList);
            });

            logger.info("Unindented item to parent level");
        }
    }
    catch (error) {
        console.error("Failed to unindent item:", error);
    }
}

// ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã‚’æœ‰åŠ¹åŒ–ï¼ˆãƒ†ã‚¹ãƒˆç’°å¢ƒã§ã®ã¿ï¼‰
if (typeof window !== 'undefined' && process.env.NODE_ENV === 'test') {
    (window as any).DEBUG_MODE = true;
}

// ã‚¢ã‚¤ãƒ†ãƒ é–“ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†
function handleNavigateToItem(event: CustomEvent) {
    const __t1 = (typeof performance !== 'undefined' && (performance as any).now) ? (performance as any).now() : Date.now();
    // Shifté¸æŠå¯¾å¿œã®ãŸã‚ shiftKey ã¨ direction ã‚‚å–å¾—
    const { direction, cursorScreenX, fromItemId, toItemId, shiftKey, t0 } = event.detail;
    // Shiftãªã—ã®ç§»å‹•ã§ã¯æ—¢å­˜ã®é¸æŠã‚’ã‚¯ãƒªã‚¢ï¼ˆéè¤‡æ•°é¸æŠã¸ï¼‰
    if (!shiftKey) {
        editorOverlayStore.clearSelections();
    }

    console.log(`â±ï¸ [Enter] handleNavigateToItem: dir=${direction}, from=${fromItemId}, to=${toItemId}, dt0=${t0!=null? (__t1 - t0): 'n/a'}ms`);

    // toItemIdãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ãã®ã‚¢ã‚¤ãƒ†ãƒ ã«ç›´æ¥ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã™ã‚‹
    if (toItemId) {
        // Enterã«ã‚ˆã‚‹æ–°è¦ä½œæˆã®å ´åˆã¯Yjsã«ã‚‚åŒIDã®ç©ºãƒãƒ¼ãƒ‰ã‚’ç”¨æ„
        if (direction === "enter" && fromItemId) {
            mirrorEnterCreationToYjs(fromItemId, toItemId);
        }

        // ä¸Šä¸‹æ–¹å‘ã®ç§»å‹•ã®å ´åˆã€ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’é©åˆ‡ã«è¨­å®š
        if (direction === "up") {
            // å‰ã®ã‚¢ã‚¤ãƒ†ãƒ ã®æœ€å¾Œã®è¡Œã«ç§»å‹•
            focusItemWithPosition(toItemId, Number.MAX_SAFE_INTEGER, shiftKey, direction);
            return;
        } else if (direction === "down") {
            // æ¬¡ã®ã‚¢ã‚¤ãƒ†ãƒ ã®æœ€åˆã®è¡Œã«ç§»å‹•
            focusItemWithPosition(toItemId, 0, shiftKey, direction);
            return;
        } else if (direction === "left" || direction === "right") {
            // å·¦å³æ–¹å‘ã®ç§»å‹•
            focusItemWithPosition(toItemId, direction === "left" ? Number.MAX_SAFE_INTEGER : 0, shiftKey, direction);
            return;
        } else {
            // directionãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆï¼ˆã‚¨ã‚¤ãƒªã‚¢ã‚¹ãƒ‘ã‚¹ã®ã‚¯ãƒªãƒƒã‚¯ãªã©ï¼‰
            focusItemWithPosition(toItemId, 0, shiftKey, undefined);
            return;
        }
    }

    // å·¦å³æ–¹å‘ã®å‡¦ç†
    if (direction === "left") {
        let currentIndex = displayItems.current.findIndex(item => item.model.id === fromItemId);
        if (currentIndex > 0) {
            // å‰ã®ã‚¢ã‚¤ãƒ†ãƒ ã«ç§»å‹•
            const targetItemId = displayItems.current[currentIndex - 1].model.id;
            focusItemWithPosition(targetItemId, Number.MAX_SAFE_INTEGER, shiftKey, 'left');
        }
        else {
            // æœ€åˆã®ã‚¢ã‚¤ãƒ†ãƒ ã®å ´åˆã¯ç¾åœ¨ã®ã‚¢ã‚¤ãƒ†ãƒ ã«ã¨ã©ã¾ã‚‹
            focusItemWithPosition(fromItemId, 0, shiftKey, 'left');
        }
        return;
    }
    else if (direction === "right") {
        let currentIndex = displayItems.current.findIndex(item => item.model.id === fromItemId);
        if (currentIndex >= 0 && currentIndex < displayItems.current.length - 1) {
            // æ¬¡ã®ã‚¢ã‚¤ãƒ†ãƒ ã«ç§»å‹•
            const targetItemId = displayItems.current[currentIndex + 1].model.id;
            focusItemWithPosition(targetItemId, 0, shiftKey, 'right');
            return;
        }
        // æœ€å¾Œã®ã‚¢ã‚¤ãƒ†ãƒ ãªã‚‰ä½•ã‚‚ã—ãªã„ï¼ˆæœ«å°¾ã¾ã§ç§»å‹•ï¼‰
        focusItemWithPosition(fromItemId, Number.MAX_SAFE_INTEGER, shiftKey, 'right');
        return;
    }

    // ä¸Šä¸‹æ–¹å‘ã®å‡¦ç†
    let currentIndex = displayItems.current.findIndex(item => item.model.id === fromItemId);

    // Shift+Down ã«ã‚ˆã‚‹è¤‡æ•°é¸æŠ: storeã®selectionsã‹ã‚‰æœ€åˆã®ç¯„å›²ã‚’å–å¾—ã—ã¦çµ‚ç«¯ã‚’æ›´æ–°
    if (shiftKey && direction === "down") {
        const selectionRanges = Object.values(editorOverlayStore.selections);
        if (selectionRanges.length === 0) return;
        const { startItemId, startOffset } = selectionRanges[0];
        const targetItemId = displayItems.current[currentIndex + 1]?.model.id;
        if (!targetItemId) return;
        const endEl = document.querySelector(`[data-item-id="${targetItemId}"] .item-text`) as HTMLElement;
        const endLen = endEl?.textContent?.length || 0;
        editorOverlayStore.setSelection({
            startItemId,
            endItemId: targetItemId,
            startOffset,
            endOffset: endLen,
            userId: 'local',
            isReversed: false
        });
        return;
    }
    // Shift+Up ã«ã‚ˆã‚‹è¤‡æ•°é¸æŠ: storeã®selectionsã‹ã‚‰æœ€åˆã®ç¯„å›²ã‚’å–å¾—ã—ã¦å§‹ç«¯ã‚’æ›´æ–°
    if (shiftKey && direction === "up") {
        const selectionRanges = Object.values(editorOverlayStore.selections);
        if (selectionRanges.length === 0) return;
        const { endItemId, endOffset } = selectionRanges[0];
        const targetItemId = displayItems.current[currentIndex - 1]?.model.id;
        if (!targetItemId) return;
        const startEl = document.querySelector(`[data-item-id="${targetItemId}"] .item-text`) as HTMLElement;
        const startLen = startEl?.textContent?.length || 0;
        editorOverlayStore.setSelection({
            startItemId: targetItemId,
            endItemId,
            startOffset: startLen,
            endOffset,
            userId: 'local',
            isReversed: true
        });
        return;
    }

    // æœ€åˆã®ã‚¢ã‚¤ãƒ†ãƒ ã§ä¸Šã«ç§»å‹•ã—ã‚ˆã†ã¨ã—ãŸå ´åˆ
    if (currentIndex === 0 && direction === "up") {
        focusItemWithPosition(fromItemId, 0, shiftKey, 'up');
        return;
    }

    // æœ€å¾Œã®ã‚¢ã‚¤ãƒ†ãƒ ã‹ã‚‰ä¸‹ã¸ç§»å‹•ã—ã‚ˆã†ã¨ã—ãŸå ´åˆ
    if (direction === "down" && currentIndex === displayItems.current.length - 1) {
        focusItemWithPosition(fromItemId, Number.MAX_SAFE_INTEGER, shiftKey, 'down');
        return;
    }

    // é€šå¸¸ã®ã‚¢ã‚¤ãƒ†ãƒ é–“ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
    let targetIndex = -1;
    if (direction === "up") {
        targetIndex = currentIndex - 1;
    }
    else if (direction === "down") {
        targetIndex = currentIndex + 1;
    }

    if (typeof window !== "undefined" && (window as any).DEBUG_MODE) {
        console.log(
            `Navigation calculation: currentIndex=${currentIndex}, targetIndex=${targetIndex}, items count=${displayItems.current.length}`,
        );
    }

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒé€šå¸¸ã®ã‚¢ã‚¤ãƒ†ãƒ ã®ç¯„å›²å†…ã«ã‚ã‚‹å ´åˆ
    if (targetIndex >= 0 && targetIndex < displayItems.current.length) {
        const targetItemId = displayItems.current[targetIndex].model.id;
        focusItemWithPosition(targetItemId, cursorScreenX, shiftKey, direction);
    }
}

// æŒ‡å®šã—ãŸã‚¢ã‚¤ãƒ†ãƒ ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã—ã€ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’è¨­å®šã™ã‚‹
function focusItemWithPosition(itemId: string, cursorScreenX?: number, shiftKey = false, direction?: string) {
    if (typeof window !== "undefined" && (window as any).DEBUG_MODE) {
        console.log(`Focusing item ${itemId} with cursor X: ${cursorScreenX}px, shift=${shiftKey}, direction=${direction}`);
    }

    const getItemEl = () => document.querySelector(`[data-item-id="${itemId}"]`) as HTMLElement | null;

    const doDispatch = (itemEl: HTMLElement) => {
        try {
            const event = new CustomEvent("focus-item", {
                detail: { cursorScreenX, shiftKey, direction },
                bubbles: false,
                cancelable: true,
            });
            itemEl.dispatchEvent(event);

            if (typeof window !== "undefined" && (window as any).DEBUG_MODE) {
                console.log(`Dispatched focus-item event to ${itemId} with X: ${cursorScreenX}px, shift=${shiftKey}`);
            }
        } catch (error) {
            console.error(`Error dispatching focus-item event to ${itemId}:`, error);
        }
    };

    const tryFocus = (attempt = 0) => {
        const itemEl = getItemEl();
        if (!itemEl) {
            if (attempt < 30) {
                requestAnimationFrame(() => tryFocus(attempt + 1));
            } else {
                console.error(`Could not find item with ID: ${itemId} after ${attempt} attempts`);
            }
            return;
        }

        // ç¾åœ¨ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã•ã‚Œã¦ã„ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚ã‚‹å ´åˆã¯ç·¨é›†ã‚’çµ‚äº†
        const activeItem = editorOverlayStore.getActiveItem();
        if (activeItem && activeItem !== itemId) {
            const activeElement = document.querySelector(`[data-item-id="${activeItem}"]`);
            if (activeElement) {
                const finishEditEvent = new CustomEvent("finish-edit");
                activeElement.dispatchEvent(finishEditEvent);
                if (typeof window !== "undefined" && (window as any).DEBUG_MODE) {
                    console.log(`Sent finish-edit event to active item ${activeItem}`);
                }
                setTimeout(() => doDispatch(itemEl), 16);
            } else {
                doDispatch(itemEl);
            }
        } else {
            doDispatch(itemEl);
        }
    };

    tryFocus();
}


// åŒã˜éšå±¤ã«æ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¿½åŠ ã™ã‚‹ãƒãƒ³ãƒ‰ãƒ©
async function handleAddSibling(event: CustomEvent) {
    console.log("ğŸ”§ [OutlinerTree] handleAddSibling called");

    const { itemId } = event.detail;
    const currentIndex = displayItems.current.findIndex(item => item.model.id === itemId);

    if (currentIndex >= 0) {
        const currentItem = displayItems.current[currentIndex];
        const parent = Tree.parent(currentItem.model.original);

        let newItem: Item | null = null;
        if (parent && Tree.is(parent, Items)) {
            // è¦ªã‚¢ã‚¤ãƒ†ãƒ ãŒå­˜åœ¨ã™ã‚‹å ´åˆã€ç¾åœ¨ã®ã‚¢ã‚¤ãƒ†ãƒ ã®ç›´å¾Œã«è¿½åŠ 
            const itemIndex = parent.indexOf(currentItem.model.original);
            newItem = parent.addNode(currentUser, itemIndex + 1);
        } else {
            // ãƒ«ãƒ¼ãƒˆãƒ¬ãƒ™ãƒ«ã®ã‚¢ã‚¤ãƒ†ãƒ ã¨ã—ã¦è¿½åŠ 
            const items = pageItem.items;
            if (items && Tree.is(items, Items)) {
                const itemIndex = items.indexOf(currentItem.model.original);
                newItem = items.addNode(currentUser, itemIndex + 1);
            }
        }

        // Fluidã‹ã‚‰Yjsã¸ã®åŒæœŸã¯ç¦æ­¢ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€Fluidã‚¢ã‚¤ãƒ†ãƒ ã®ã¿å‡¦ç†
        if (newItem) {
            console.log(`ğŸ”§ [OutlinerTree] Fluid sibling item created via handleAddSibling: ${newItem.id} for "${newItem.text}"`);
        }
    }
}


// è¤‡æ•°è¡Œãƒšãƒ¼ã‚¹ãƒˆæ™‚ã«æ–°è¦ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¿½åŠ 
function handlePasteMultiItem(event: CustomEvent) {
    const { lines, selections, activeItemId } = event.detail;

    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±
    if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
        console.log(`handlePasteMultiItem called with lines:`, lines);
        console.log(`Selections:`, selections);
        console.log(`Active item ID: ${activeItemId}`);
    }

    // ãƒ†ã‚¹ãƒˆç”¨ã«ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«è¨­å®š
    if (typeof window !== 'undefined') {
        (window as any).lastPasteLines = lines;
        (window as any).lastPasteSelections = selections;
        (window as any).lastPasteActiveItemId = activeItemId;
    }

    // é¸æŠç¯„å›²ãŒã‚ã‚‹å ´åˆã¯ã€é¸æŠç¯„å›²ã‚’å‰Šé™¤ã—ã¦ã‹ã‚‰ãƒšãƒ¼ã‚¹ãƒˆ
    if (selections && selections.length > 0) {
        // è¤‡æ•°ã‚¢ã‚¤ãƒ†ãƒ ã«ã¾ãŸãŒã‚‹é¸æŠç¯„å›²ãŒã‚ã‚‹å ´åˆ
        const multiItemSelection = selections.find((sel: any) => sel.startItemId !== sel.endItemId);

        if (multiItemSelection) {
            // è¤‡æ•°ã‚¢ã‚¤ãƒ†ãƒ ã«ã¾ãŸãŒã‚‹é¸æŠç¯„å›²ã‚’å‡¦ç†
            handleMultiItemSelectionPaste(multiItemSelection, lines);
            return;
        }

        // å˜ä¸€ã‚¢ã‚¤ãƒ†ãƒ å†…ã®é¸æŠç¯„å›²ã‚’å‡¦ç†
        const singleItemSelection = selections[0];
        if (singleItemSelection) {
            handleSingleItemSelectionPaste(singleItemSelection, lines);
            return;
        }
    }

    // é¸æŠç¯„å›²ãŒãªã„å ´åˆã¯ã€ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¢ã‚¤ãƒ†ãƒ ã«ãƒšãƒ¼ã‚¹ãƒˆ
    // æœ€åˆã®é¸æŠã‚¢ã‚¤ãƒ†ãƒ ã‚’ãƒ™ãƒ¼ã‚¹ã¨ã™ã‚‹
    const firstItemId = activeItemId;
    const itemIndex = displayItems.current.findIndex(d => d.model.id === firstItemId);

    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¢ã‚¤ãƒ†ãƒ ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯æœ€åˆã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’ä½¿ç”¨
    if (itemIndex < 0) {
        if (displayItems.current.length > 0) {
            const firstAvailableItemId = displayItems.current[0].model.id;
            const firstAvailableIndex = 0;

            if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
                console.log(`Active item not found, using first available item: ${firstAvailableItemId}`);
            }

            // æœ€åˆã®ã‚¢ã‚¤ãƒ†ãƒ ã«ãƒšãƒ¼ã‚¹ãƒˆ
            const items = pageItem.items as Items;
            const baseOriginal = displayItems.current[firstAvailableIndex].model.original;
            baseOriginal.text = lines[0] || '';

            // æ®‹ã‚Šã®è¡Œã‚’æ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ ã¨ã—ã¦è¿½åŠ 
            for (let i = 1; i < lines.length; i++) {
                const newIndex = firstAvailableIndex + i;
                items.addNode(currentUser, newIndex);
                // è¿½åŠ ç›´å¾Œã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’é…åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§å–å¾—ã—ãƒ†ã‚­ã‚¹ãƒˆè¨­å®š
                const newItem = items[newIndex];
                if (newItem) {
                    newItem.text = lines[i];
                }
            }

            return;
        }

        return;
    }

    const items = pageItem.items as Items;

    // æ—¢å­˜ã®é¸æŠã‚¢ã‚¤ãƒ†ãƒ ã‚’æ›´æ–°
    const baseOriginal = displayItems.current[itemIndex].model.original;
    baseOriginal.text = lines[0] || '';

    // æ®‹ã‚Šã®è¡Œã§ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¿½åŠ 
    for (let i = 1; i < lines.length; i++) {
        const newIndex = itemIndex + i;
        items.addNode(currentUser, newIndex);
        // è¿½åŠ ç›´å¾Œã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’é…åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§å–å¾—ã—ãƒ†ã‚­ã‚¹ãƒˆè¨­å®š
        const newItem = items[newIndex];
        if (newItem) {
            newItem.text = lines[i];
        }
    }
}

// è¤‡æ•°ã‚¢ã‚¤ãƒ†ãƒ ã«ã¾ãŸãŒã‚‹é¸æŠç¯„å›²ã«ãƒšãƒ¼ã‚¹ãƒˆã™ã‚‹
function handleMultiItemSelectionPaste(selection: any, lines: string[]) {
    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±
    if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
        console.log(`handleMultiItemSelectionPaste called with selection:`, selection);
        console.log(`Lines to paste:`, lines);
    }

    // é¸æŠç¯„å›²ã®é–‹å§‹ã¨çµ‚äº†ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
    const startItemId = selection.startItemId;
    const endItemId = selection.endItemId;

    // ã‚¢ã‚¤ãƒ†ãƒ ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
    const startIndex = displayItems.current.findIndex(d => d.model.id === startItemId);
    const endIndex = displayItems.current.findIndex(d => d.model.id === endItemId);

    if (startIndex < 0 || endIndex < 0) {
        if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
            console.log(`Start or end item not found: startIndex=${startIndex}, endIndex=${endIndex}`);
        }
        return;
    }

    // é¸æŠç¯„å›²ã®æ–¹å‘ã‚’è€ƒæ…®
    const isReversed = selection.isReversed || false;
    const actualStartIndex = Math.min(startIndex, endIndex);
    const actualEndIndex = Math.max(startIndex, endIndex);

    if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
        console.log(`Selection direction: isReversed=${isReversed}`);
        console.log(`Actual indices: start=${actualStartIndex}, end=${actualEndIndex}`);
    }

    const items = pageItem.items as Items;

    // é¸æŠç¯„å›²å†…ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’å‰Šé™¤ï¼ˆå¾Œã‚ã‹ã‚‰å‰Šé™¤ï¼‰
    for (let i = actualEndIndex; i >= actualStartIndex; i--) {
        if (i === actualStartIndex) {
            // é–‹å§‹ã‚¢ã‚¤ãƒ†ãƒ ã¯å‰Šé™¤ã›ãšã€ãƒ†ã‚­ã‚¹ãƒˆã‚’æ›´æ–°
            const startItem = displayItems.current[i].model.original;
            startItem.text = lines[0] || '';

            if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
                console.log(`Updated first item text to: "${lines[0] || ''}"`);
            }
        } else {
            // ãã‚Œä»¥å¤–ã®ã‚¢ã‚¤ãƒ†ãƒ ã¯å‰Šé™¤
            if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
                console.log(`Removing item at index ${i}`);
            }
            items.removeAt(i);
        }
    }

    // æ®‹ã‚Šã®è¡Œã‚’æ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ ã¨ã—ã¦è¿½åŠ 
    for (let i = 1; i < lines.length; i++) {
        const newIndex = actualStartIndex + i;
        if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
            console.log(`Adding new item at index ${newIndex} with text: "${lines[i]}"`);
        }
        items.addNode(currentUser, newIndex);
        // è¿½åŠ ç›´å¾Œã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’é…åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§å–å¾—ã—ãƒ†ã‚­ã‚¹ãƒˆè¨­å®š
        const newItem = items[newIndex];
        if (newItem) {
            newItem.text = lines[i];
        }
    }

    // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’æ›´æ–°
    const newCursorItemId = displayItems.current[actualStartIndex]?.model.id;
    if (newCursorItemId) {
        if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
            console.log(`Setting cursor to item ${newCursorItemId} at offset ${(lines[0] || '').length}`);
        }

        editorOverlayStore.setCursor({
            itemId: newCursorItemId,
            offset: (lines[0] || '').length,
            isActive: true,
            userId: 'local'
        });

        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¨­å®š
        editorOverlayStore.setActiveItem(newCursorItemId);

        // é¸æŠç¯„å›²ã‚’ã‚¯ãƒªã‚¢
        editorOverlayStore.clearSelections();
    } else {
        if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
            console.log(`Could not find cursor item at index ${actualStartIndex}`);
        }
    }
}

// å˜ä¸€ã‚¢ã‚¤ãƒ†ãƒ å†…ã®é¸æŠç¯„å›²ã«ãƒšãƒ¼ã‚¹ãƒˆã™ã‚‹
function handleSingleItemSelectionPaste(selection: any, lines: string[]) {
    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±
    if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
        console.log(`handleSingleItemSelectionPaste called with selection:`, selection);
        console.log(`Lines to paste:`, lines);
    }

    const itemId = selection.startItemId;
    const startOffset = Math.min(selection.startOffset, selection.endOffset);
    const endOffset = Math.max(selection.startOffset, selection.endOffset);

    // ã‚¢ã‚¤ãƒ†ãƒ ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
    const itemIndex = displayItems.current.findIndex(d => d.model.id === itemId);
    if (itemIndex < 0) {
        if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
            console.log(`Item not found: itemId=${itemId}, itemIndex=${itemIndex}`);
        }
        return;
    }

    const items = pageItem.items as Items;
    const item = displayItems.current[itemIndex].model.original;
    const text = (item.text as string) || '';

    if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
        console.log(`Original text: "${text}"`);
        console.log(`Selection range: start=${startOffset}, end=${endOffset}`);
    }

    if (lines.length === 1) {
        // å˜ä¸€è¡Œã®ãƒšãƒ¼ã‚¹ãƒˆã®å ´åˆã¯ã€é¸æŠç¯„å›²ã‚’ç½®ãæ›ãˆ
        const newText = text.substring(0, startOffset) + lines[0] + text.substring(endOffset);
        item.text = newText;

        if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
            console.log(`Updated text to: "${newText}"`);
        }

        // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’æ›´æ–°
        editorOverlayStore.setCursor({
            itemId,
            offset: startOffset + lines[0].length,
            isActive: true,
            userId: 'local'
        });

        // é¸æŠç¯„å›²ã‚’ã‚¯ãƒªã‚¢
        editorOverlayStore.clearSelections();
    } else {
        // è¤‡æ•°è¡Œã®ãƒšãƒ¼ã‚¹ãƒˆã®å ´åˆ
        // æœ€åˆã®è¡Œã¯ç¾åœ¨ã®ã‚¢ã‚¤ãƒ†ãƒ ã®é¸æŠç¯„å›²ã‚’ç½®ãæ›ãˆ
        const newFirstText = text.substring(0, startOffset) + lines[0];
        item.text = newFirstText;

        if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
            console.log(`Updated first item text to: "${newFirstText}"`);
        }

        // æ®‹ã‚Šã®è¡Œã‚’æ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ ã¨ã—ã¦è¿½åŠ 
        for (let i = 1; i < lines.length; i++) {
            const newIndex = itemIndex + i;

            if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
                console.log(`Adding new item at index ${newIndex}`);
            }

            items.addNode(currentUser, newIndex);
            // è¿½åŠ ç›´å¾Œã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’é…åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§å–å¾—ã—ãƒ†ã‚­ã‚¹ãƒˆè¨­å®š
            const newItem = items[newIndex];
            if (newItem) {
                if (i === lines.length - 1) {
                    // æœ€å¾Œã®è¡Œã¯ã€é¸æŠç¯„å›²ã®å¾Œã‚ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’è¿½åŠ 
                    const lastItemText = lines[i] + text.substring(endOffset);
                    newItem.text = lastItemText;

                    if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
                        console.log(`Last item text set to: "${lastItemText}"`);
                    }
                } else {
                    newItem.text = lines[i];

                    if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
                        console.log(`Item ${i} text set to: "${lines[i]}"`);
                    }
                }
            }
        }

        // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’æ›´æ–°ï¼ˆæœ€å¾Œã®ã‚¢ã‚¤ãƒ†ãƒ ã®æœ«å°¾ï¼‰
        const lastItemIndex = itemIndex + lines.length - 1;
        const lastItemId = displayItems.current[lastItemIndex]?.model.id;
        if (lastItemId) {
            const lastLine = lines[lines.length - 1];
            const newOffset = lastLine.length;

            if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
                console.log(`Setting cursor to last item ${lastItemId} at offset ${newOffset}`);
            }

            editorOverlayStore.setCursor({
                itemId: lastItemId,
                offset: newOffset,
                isActive: true,
                userId: 'local'
            });

            // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¨­å®š
            editorOverlayStore.setActiveItem(lastItemId);

            // é¸æŠç¯„å›²ã‚’ã‚¯ãƒªã‚¢
            editorOverlayStore.clearSelections();
        } else {
            if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
                console.log(`Could not find last item at index ${lastItemIndex}`);
            }
        }
    }
}

// ãƒ„ãƒªãƒ¼å…¨ä½“ã®ãƒã‚¦ã‚¹ãƒ€ã‚¦ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
function handleTreeMouseDown(event: MouseEvent) {
    // å³ã‚¯ãƒªãƒƒã‚¯ã¯ç„¡è¦–
    if (event.button !== 0) return;

    // æ—¢ã«å‡¦ç†ã•ã‚ŒãŸã‚¤ãƒ™ãƒ³ãƒˆã¯ç„¡è¦–
    if (event.defaultPrevented) return;

    // ã‚¢ã‚¤ãƒ†ãƒ å†…ã®ã‚¯ãƒªãƒƒã‚¯ã¯ç„¡è¦–ï¼ˆOutlinerItemã§å‡¦ç†ã•ã‚Œã‚‹ï¼‰
    const target = event.target as HTMLElement;
    if (target.closest('.outliner-item')) return;

    // é¸æŠç¯„å›²ã‚’ã‚¯ãƒªã‚¢
    editorOverlayStore.clearSelections();
}

// ãƒ„ãƒªãƒ¼å…¨ä½“ã®ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
function handleTreeMouseUp() {
    // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã§ãªã„å ´åˆã¯ç„¡è¦–
    if (!isDragging) return;

    // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†
    isDragging = false;

    // ãƒ‰ãƒ©ãƒƒã‚°æƒ…å ±ã‚’ãƒªã‚»ãƒƒãƒˆ
    dragStartItemId = null;
    dragCurrentItemId = null;
}

// ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
function handleItemDragStart(event: CustomEvent) {
    const { itemId, offset } = event.detail;

    // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æƒ…å ±ã‚’ä¿å­˜
    isDragging = true;
    dragStartItemId = itemId;
    dragStartOffset = offset;
    dragCurrentItemId = itemId;
    dragCurrentOffset = offset;

    if (typeof window !== "undefined" && (window as any).DEBUG_MODE) {
        console.log(`Drag start: itemId=${itemId}, offset=${offset}`);
    }
}

// ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
function handleItemDrag(event: CustomEvent) {
    const { itemId, offset } = event.detail;

    // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã§ãªã„å ´åˆã¯ç„¡è¦–
    if (!isDragging || !dragStartItemId) return;

    // ç¾åœ¨ã®ãƒ‰ãƒ©ãƒƒã‚°ä½ç½®ã‚’æ›´æ–°
    dragCurrentItemId = itemId;
    dragCurrentOffset = offset;

    // é¸æŠç¯„å›²ã‚’æ›´æ–°
    updateDragSelection();

    if (typeof window !== "undefined" && (window as any).DEBUG_MODE) {
        console.log(`Dragging: itemId=${itemId}, offset=${offset}`);
    }
}

// ãƒ‰ãƒ©ãƒƒã‚°é¸æŠç¯„å›²ã‚’æ›´æ–°ã™ã‚‹
function updateDragSelection() {
    if (!dragStartItemId || !dragCurrentItemId) return;

    // é–‹å§‹ã‚¢ã‚¤ãƒ†ãƒ ã¨ç¾åœ¨ã®ã‚¢ã‚¤ãƒ†ãƒ ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
    const startIndex = displayItems.current.findIndex(item => item.model.id === dragStartItemId);
    const currentIndex = displayItems.current.findIndex(item => item.model.id === dragCurrentItemId);

    if (startIndex === -1 || currentIndex === -1) return;

    // é¸æŠæ–¹å‘ã‚’æ±ºå®š
    const isReversed = startIndex > currentIndex ||
                      (startIndex === currentIndex && dragStartOffset > dragCurrentOffset);

    // é¸æŠç¯„å›²ã®é–‹å§‹ã¨çµ‚äº†ã‚’æ±ºå®š
    const startItemId = isReversed ? dragCurrentItemId : dragStartItemId;
    const startOffset = isReversed ? dragCurrentOffset : dragStartOffset;
    const endItemId = isReversed ? dragStartItemId : dragCurrentItemId;
    const endOffset = isReversed ? dragStartOffset : dragCurrentOffset;

    // é¸æŠç¯„å›²ã‚’è¨­å®š
    editorOverlayStore.setSelection({
        startItemId,
        startOffset,
        endItemId,
        endOffset,
        userId: 'local',
        isReversed
    });

    // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’æ›´æ–°
    editorOverlayStore.setCursor({
        itemId: dragCurrentItemId,
        offset: dragCurrentOffset,
        isActive: true,
        userId: 'local'
    });

    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¨­å®š
    editorOverlayStore.setActiveItem(dragCurrentItemId);
}

// ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
function handleItemDrop(event: CustomEvent) {
    const { targetItemId, position, text, selection, sourceItemId } = event.detail;

    if (typeof window !== "undefined" && (window as any).DEBUG_MODE) {
        console.log(`Drop event: targetItemId=${targetItemId}, position=${position}, sourceItemId=${sourceItemId}`);
        console.log(`Text: "${text}"`);
        console.log(`Selection:`, selection);
    }

    // é¸æŠç¯„å›²ãŒã‚ã‚‹å ´åˆã¯ã€é¸æŠç¯„å›²ã‚’å‰Šé™¤ã—ã¦ã‹ã‚‰ãƒ‰ãƒ­ãƒƒãƒ—
    if (selection) {
        // é¸æŠç¯„å›²ã®å‰Šé™¤å‡¦ç†
        const startItemId = selection.startItemId;
        const endItemId = selection.endItemId;

        // å˜ä¸€ã‚¢ã‚¤ãƒ†ãƒ å†…ã®é¸æŠç¯„å›²
        if (startItemId === endItemId) {
            handleSingleItemSelectionDrop(selection, targetItemId, position, text);
        } else {
            // è¤‡æ•°ã‚¢ã‚¤ãƒ†ãƒ ã«ã¾ãŸãŒã‚‹é¸æŠç¯„å›²
            handleMultiItemSelectionDrop(selection, targetItemId, position, text);
        }
    } else if (sourceItemId) {
        // å˜ä¸€ã‚¢ã‚¤ãƒ†ãƒ å…¨ä½“ã®ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—
        handleItemMoveDrop(sourceItemId, targetItemId, position);
    } else {
        // å¤–éƒ¨ã‹ã‚‰ã®ãƒ†ã‚­ã‚¹ãƒˆãƒ‰ãƒ­ãƒƒãƒ—
        handleExternalTextDrop(targetItemId, position, text);
    }

    // ãƒ‰ãƒ©ãƒƒã‚°çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
    isDragging = false;
    dragStartItemId = null;
    dragCurrentItemId = null;
}

// ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
function handleItemDragEnd(event: CustomEvent) {
    const { itemId } = event.detail;

    if (typeof window !== "undefined" && (window as any).DEBUG_MODE) {
        console.log(`Drag end: itemId=${itemId}`);
    }

    // ãƒ‰ãƒ©ãƒƒã‚°çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
    isDragging = false;
    dragStartItemId = null;
    dragCurrentItemId = null;
}

// å˜ä¸€ã‚¢ã‚¤ãƒ†ãƒ å†…ã®é¸æŠç¯„å›²ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã™ã‚‹
function handleSingleItemSelectionDrop(selection: any, targetItemId: string, position: string, text: string) {
    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±
    if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
        console.log(`handleSingleItemSelectionDrop called with selection:`, selection);
        console.log(`Target: itemId=${targetItemId}, position=${position}`);
    }

    const sourceItemId = selection.startItemId;
    const startOffset = Math.min(selection.startOffset, selection.endOffset);
    const endOffset = Math.max(selection.startOffset, selection.endOffset);

    // ã‚½ãƒ¼ã‚¹ã‚¢ã‚¤ãƒ†ãƒ ã¨ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¢ã‚¤ãƒ†ãƒ ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
    const sourceIndex = displayItems.current.findIndex(d => d.model.id === sourceItemId);
    const targetIndex = displayItems.current.findIndex(d => d.model.id === targetItemId);

    if (sourceIndex < 0 || targetIndex < 0) {
        if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
            console.log(`Source or target item not found: sourceIndex=${sourceIndex}, targetIndex=${targetIndex}`);
        }
        return;
    }

    // ã‚½ãƒ¼ã‚¹ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
    const sourceItem = displayItems.current[sourceIndex].model.original;
    const sourceText = sourceItem.text || '';

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
    const targetItem = displayItems.current[targetIndex].model.original;
    const targetText = targetItem.text || '';

    // é¸æŠç¯„å›²ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
    const selectedText = sourceText.substring(startOffset, endOffset);

    if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
        console.log(`Selected text: "${selectedText}"`);
    }

    // ã‚½ãƒ¼ã‚¹ã‚¢ã‚¤ãƒ†ãƒ ã‹ã‚‰é¸æŠç¯„å›²ã‚’å‰Šé™¤
    const newSourceText = sourceText.substring(0, startOffset) + sourceText.substring(endOffset);
    sourceItem.text = newSourceText;

    if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
        console.log(`Updated source text: "${newSourceText}"`);
    }

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¢ã‚¤ãƒ†ãƒ ã«é¸æŠç¯„å›²ã‚’æŒ¿å…¥
    if (position === 'top') {
        // ã‚¢ã‚¤ãƒ†ãƒ ã®å…ˆé ­ã«æŒ¿å…¥
        targetItem.text = selectedText + targetText;
    } else if (position === 'bottom') {
        // ã‚¢ã‚¤ãƒ†ãƒ ã®æœ«å°¾ã«æŒ¿å…¥
        targetItem.text = targetText + selectedText;
    } else if (position === 'middle') {
        // ã‚¢ã‚¤ãƒ†ãƒ ã®ä¸­å¤®ã«æŒ¿å…¥ï¼ˆã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’è¨ˆç®—ï¼‰
        const middleOffset = Math.floor(targetText.length / 2);
        targetItem.text = targetText.substring(0, middleOffset) + selectedText + targetText.substring(middleOffset);
    }

    if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
        console.log(`Updated target text: "${targetItem.text}"`);
    }

    // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’æ›´æ–°
    editorOverlayStore.setCursor({
        itemId: targetItemId,
        offset: position === 'top' ? selectedText.length :
                position === 'bottom' ? targetText.length + selectedText.length :
                Math.floor(targetText.length / 2) + selectedText.length,
        isActive: true,
        userId: 'local'
    });

    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¨­å®š
    editorOverlayStore.setActiveItem(targetItemId);

    // é¸æŠç¯„å›²ã‚’ã‚¯ãƒªã‚¢
    editorOverlayStore.clearSelections();
}

// è¤‡æ•°ã‚¢ã‚¤ãƒ†ãƒ ã«ã¾ãŸãŒã‚‹é¸æŠç¯„å›²ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã™ã‚‹
function handleMultiItemSelectionDrop(selection: any, targetItemId: string, position: string, text: string) {
    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±
    if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
        console.log(`handleMultiItemSelectionDrop called with selection:`, selection);
        console.log(`Target: itemId=${targetItemId}, position=${position}`);
    }

    // é¸æŠç¯„å›²ã®é–‹å§‹ã¨çµ‚äº†ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
    const startItemId = selection.startItemId;
    const endItemId = selection.endItemId;

    // ã‚¢ã‚¤ãƒ†ãƒ ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
    const startIndex = displayItems.current.findIndex(d => d.model.id === startItemId);
    const endIndex = displayItems.current.findIndex(d => d.model.id === endItemId);
    const targetIndex = displayItems.current.findIndex(d => d.model.id === targetItemId);

    if (startIndex < 0 || endIndex < 0 || targetIndex < 0) {
        if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
            console.log(`Start, end, or target item not found: startIndex=${startIndex}, endIndex=${endIndex}, targetIndex=${targetIndex}`);
        }
        return;
    }

    // é¸æŠç¯„å›²ã®æ–¹å‘ã‚’è€ƒæ…®
    const isReversed = selection.isReversed || false;
    const actualStartIndex = Math.min(startIndex, endIndex);
    const actualEndIndex = Math.max(startIndex, endIndex);

    // é¸æŠç¯„å›²å†…ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
    const selectedText = text;

    if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
        console.log(`Selected text: "${selectedText}"`);
    }

    const items = pageItem.items as Items;

    // é¸æŠç¯„å›²å†…ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’å‰Šé™¤ï¼ˆå¾Œã‚ã‹ã‚‰å‰Šé™¤ï¼‰
    for (let i = actualEndIndex; i >= actualStartIndex; i--) {
        if (i === actualStartIndex) {
            // é–‹å§‹ã‚¢ã‚¤ãƒ†ãƒ ã¯å‰Šé™¤ã›ãšã€ãƒ†ã‚­ã‚¹ãƒˆã‚’æ›´æ–°
            const startItem = displayItems.current[i].model.original;
            startItem.text = '';

            if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
                console.log(`Cleared first item text`);
            }
        } else {
            // ãã‚Œä»¥å¤–ã®ã‚¢ã‚¤ãƒ†ãƒ ã¯å‰Šé™¤
            if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
                console.log(`Removing item at index ${i}`);
            }
            items.removeAt(i);
        }
    }

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
    const targetItem = displayItems.current[targetIndex].model.original;
    const targetText = targetItem.text || '';

    // é¸æŠç¯„å›²ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡Œã«åˆ†å‰²
    const lines = selectedText.split('\n');

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¢ã‚¤ãƒ†ãƒ ã«é¸æŠç¯„å›²ã‚’æŒ¿å…¥
    if (position === 'top') {
        // ã‚¢ã‚¤ãƒ†ãƒ ã®å…ˆé ­ã«æŒ¿å…¥
        targetItem.text = lines[0] + targetText;

        // æ®‹ã‚Šã®è¡Œã‚’æ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ ã¨ã—ã¦è¿½åŠ 
        for (let i = 1; i < lines.length; i++) {
            items.addNode(currentUser, targetIndex + i);
            const newItem = items[targetIndex + i];
            if (newItem) {
                newItem.text = lines[i];
            }
        }
    } else if (position === 'bottom') {
        // ã‚¢ã‚¤ãƒ†ãƒ ã®æœ«å°¾ã«æŒ¿å…¥
        targetItem.text = targetText + lines[0];

        // æ®‹ã‚Šã®è¡Œã‚’æ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ ã¨ã—ã¦è¿½åŠ 
        for (let i = 1; i < lines.length; i++) {
            items.addNode(currentUser, targetIndex + i);
            const newItem = items[targetIndex + i];
            if (newItem) {
                newItem.text = lines[i];
            }
        }
    } else if (position === 'middle') {
        // ã‚¢ã‚¤ãƒ†ãƒ ã®ä¸­å¤®ã«æŒ¿å…¥ï¼ˆã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’è¨ˆç®—ï¼‰
        const middleOffset = Math.floor(targetText.length / 2);
        targetItem.text = targetText.substring(0, middleOffset) + lines[0] + targetText.substring(middleOffset);

        // æ®‹ã‚Šã®è¡Œã‚’æ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ ã¨ã—ã¦è¿½åŠ 
        for (let i = 1; i < lines.length; i++) {
            items.addNode(currentUser, targetIndex + i);
            const newItem = items[targetIndex + i];
            if (newItem) {
                newItem.text = lines[i];
            }
        }
    }

    if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
        console.log(`Updated target text: "${targetItem.text}"`);
    }

    // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’æ›´æ–°
    editorOverlayStore.setCursor({
        itemId: targetItemId,
        offset: position === 'top' ? lines[0].length :
                position === 'bottom' ? targetText.length + lines[0].length :
                Math.floor(targetText.length / 2) + lines[0].length,
        isActive: true,
        userId: 'local'
    });

    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¨­å®š
    editorOverlayStore.setActiveItem(targetItemId);

    // é¸æŠç¯„å›²ã‚’ã‚¯ãƒªã‚¢
    editorOverlayStore.clearSelections();
}

// ã‚¢ã‚¤ãƒ†ãƒ å…¨ä½“ã‚’ç§»å‹•ã™ã‚‹
function handleItemMoveDrop(sourceItemId: string, targetItemId: string, position: string) {
    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±
    if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
        console.log(`handleItemMoveDrop called with sourceItemId=${sourceItemId}, targetItemId=${targetItemId}, position=${position}`);
    }

    // ã‚½ãƒ¼ã‚¹ã‚¢ã‚¤ãƒ†ãƒ ã¨ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¢ã‚¤ãƒ†ãƒ ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
    const sourceIndex = displayItems.current.findIndex(d => d.model.id === sourceItemId);
    const targetIndex = displayItems.current.findIndex(d => d.model.id === targetItemId);

    if (sourceIndex < 0 || targetIndex < 0) {
        if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
            console.log(`Source or target item not found: sourceIndex=${sourceIndex}, targetIndex=${targetIndex}`);
        }
        return;
    }

    // ã‚½ãƒ¼ã‚¹ã‚¢ã‚¤ãƒ†ãƒ ã¨ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¢ã‚¤ãƒ†ãƒ ãŒåŒã˜å ´åˆã¯ä½•ã‚‚ã—ãªã„
    if (sourceIndex === targetIndex) {
        if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
            console.log(`Source and target are the same item, no action needed`);
        }
        return;
    }

    const items = pageItem.items as Items;

    // ã‚½ãƒ¼ã‚¹ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
    const sourceItem = displayItems.current[sourceIndex].model.original;
    const sourceText = sourceItem.text || '';

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ä½ç½®ã‚’è¨ˆç®—
    let targetPosition = targetIndex;
    if (position === 'bottom') {
        targetPosition = targetIndex + 1;
    }

    // ã‚½ãƒ¼ã‚¹ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚ˆã‚Šå‰ã«ã‚ã‚‹å ´åˆã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã‚’èª¿æ•´
    if (sourceIndex < targetPosition) {
        targetPosition--;
    }

    if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
        console.log(`Moving item from index ${sourceIndex} to index ${targetPosition}`);
    }

    // ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç§»å‹•
    try {
        // ã‚½ãƒ¼ã‚¹ã‚¢ã‚¤ãƒ†ãƒ ã‚’å‰Šé™¤
        items.removeAt(sourceIndex);

        // æ–°ã—ã„ä½ç½®ã«ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¿½åŠ 
        items.addNode(currentUser, targetPosition);
        const newItem = items[targetPosition];
        if (newItem) {
            newItem.text = sourceText;
        }

        // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’æ›´æ–°
        editorOverlayStore.setCursor({
            itemId: newItem.id,
            offset: 0,
            isActive: true,
            userId: 'local'
        });

        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¨­å®š
        editorOverlayStore.setActiveItem(newItem.id);

        // é¸æŠç¯„å›²ã‚’ã‚¯ãƒªã‚¢
        editorOverlayStore.clearSelections();
    } catch (error) {
        console.error('Failed to move item:', error);
    }
}

// å¤–éƒ¨ã‹ã‚‰ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã™ã‚‹
function handleExternalTextDrop(targetItemId: string, position: string, text: string) {
    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±
    if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
        console.log(`handleExternalTextDrop called with targetItemId=${targetItemId}, position=${position}`);
        console.log(`Text: "${text}"`);
    }

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¢ã‚¤ãƒ†ãƒ ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
    const targetIndex = displayItems.current.findIndex(d => d.model.id === targetItemId);

    if (targetIndex < 0) {
        if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
            console.log(`Target item not found: targetIndex=${targetIndex}`);
        }
        return;
    }

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
    const targetItem = displayItems.current[targetIndex].model.original;
    const targetText = targetItem.text || '';

    // ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡Œã«åˆ†å‰²
    const lines = text.split('\n');

    const items = pageItem.items as Items;

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¢ã‚¤ãƒ†ãƒ ã«ãƒ†ã‚­ã‚¹ãƒˆã‚’æŒ¿å…¥
    if (position === 'top') {
        // ã‚¢ã‚¤ãƒ†ãƒ ã®å…ˆé ­ã«æŒ¿å…¥
        targetItem.text = lines[0] + targetText;

        // æ®‹ã‚Šã®è¡Œã‚’æ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ ã¨ã—ã¦è¿½åŠ 
        for (let i = 1; i < lines.length; i++) {
            items.addNode(currentUser, targetIndex + i);
            const newItem = items[targetIndex + i];
            if (newItem) {
                newItem.text = lines[i];
            }
        }
    } else if (position === 'bottom') {
        // ã‚¢ã‚¤ãƒ†ãƒ ã®æœ«å°¾ã«æŒ¿å…¥
        targetItem.text = targetText + lines[0];

        // æ®‹ã‚Šã®è¡Œã‚’æ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ ã¨ã—ã¦è¿½åŠ 
        for (let i = 1; i < lines.length; i++) {
            items.addNode(currentUser, targetIndex + i);
            const newItem = items[targetIndex + i];
            if (newItem) {
                newItem.text = lines[i];
            }
        }
    } else if (position === 'middle') {
        // ã‚¢ã‚¤ãƒ†ãƒ ã®ä¸­å¤®ã«æŒ¿å…¥ï¼ˆã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’è¨ˆç®—ï¼‰
        const middleOffset = Math.floor(targetText.length / 2);
        targetItem.text = targetText.substring(0, middleOffset) + lines[0] + targetText.substring(middleOffset);

        // æ®‹ã‚Šã®è¡Œã‚’æ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ ã¨ã—ã¦è¿½åŠ 
        for (let i = 1; i < lines.length; i++) {
            items.addNode(currentUser, targetIndex + i);
            const newItem = items[targetIndex + i];
            if (newItem) {
                newItem.text = lines[i];
            }
        }
    }

    if (typeof window !== 'undefined' && (window as any).DEBUG_MODE) {
        console.log(`Updated target text: "${targetItem.text}"`);
    }

    // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’æ›´æ–°
    editorOverlayStore.setCursor({
        itemId: targetItemId,
        offset: position === 'top' ? lines[0].length :
                position === 'bottom' ? targetText.length + lines[0].length :
                Math.floor(targetText.length / 2) + lines[0].length,
        isActive: true,
        userId: 'local'
    });

    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¨­å®š
    editorOverlayStore.setActiveItem(targetItemId);

    // é¸æŠç¯„å›²ã‚’ã‚¯ãƒªã‚¢
    editorOverlayStore.clearSelections();
}

// helper functions after script


// Enterã«ã‚ˆã‚‹æ–°è¦ã‚¢ã‚¤ãƒ†ãƒ ä½œæˆæ™‚ã®Yjsä¸¦åˆ—è¿½åŠ ï¼ˆç„¡åŠ¹åŒ– - ãƒ¢ãƒ¼ãƒ‰åˆ†é›¢ã®ãŸã‚ï¼‰
function mirrorEnterCreationToYjs(fromItemId: string, toItemId: string) {
    // ä¸¦è¡Œå‡¦ç†ã¯å‰Šé™¤ï¼ˆãƒ¢ãƒ¼ãƒ‰åˆ†é›¢ã®ãŸã‚ï¼‰
    console.log(`[OutlinerTree] mirrorEnterCreationToYjs disabled for mode separation`);
    return;
}

</script>

<!-- svelte-ignore a11y_no_static_element_interactions -->
<!-- svelte-ignore a11y_no_noninteractive_element_interactions -->
<div class="outliner" bind:this={containerRef} onmousedown={handleTreeMouseDown} onmouseup={handleTreeMouseUp} role="application">
    <div class="toolbar">
        <div class="actions">
            {#if !isReadOnly}
                <button onclick={() => {
                    console.log("ğŸ”§ [OutlinerTree] Button clicked, calling handleAddItem");
                    handleAddItem();
                }}>ã‚¢ã‚¤ãƒ†ãƒ è¿½åŠ </button>
            {/if}
            <button onclick={() => goto(`/${projectName}/${pageName}/diff`)}>
                History / Diff
            </button>
        </div>
    </div>

    <div class="tree-container" role="region" aria-label="ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒŠãƒ¼ãƒ„ãƒªãƒ¼">
        <!-- ãƒ•ãƒ©ãƒƒãƒˆè¡¨ç¤ºã®å„ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆçµ¶å¯¾ä½ç½®é…ç½®ï¼‰ -->
        {#each displayItems.current as display, index (display.model.id)}
            <div
                class="item-container"
                style="--item-depth: {display.depth}; top: {itemPositions[index] ?? 0}px"
                bind:clientHeight={itemHeights[index]}
            >
                <OutlinerItem
                    model={display.model}
                    depth={display.depth}
                    currentUser={currentUser}
                    isReadOnly={isReadOnly}
                    isCollapsed={viewModel.isCollapsed(display.model.id)}
                    hasChildren={viewModel.hasChildren(display.model.id)}
                    isPageTitle={index === 0}
                    {index}
                    on:toggle-collapse={handleToggleCollapse}
                    on:indent={handleIndent}
                    on:unindent={handleUnindent}
                    on:navigate-to-item={handleNavigateToItem}
                    on:resize={handleItemResize}
                    on:add-sibling={handleAddSibling}
                    on:drag-start={handleItemDragStart}
                    on:drag={handleItemDrag}
                    on:drop={handleItemDrop}
                    on:drag-end={handleItemDragEnd}
                />
            </div>
        {/each}

        {#if displayItems.current.length === 0 && !isReadOnly}
            <div class="empty-state">
                <p>
                    ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã€Œã‚¢ã‚¤ãƒ†ãƒ è¿½åŠ ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦å§‹ã‚ã¾ã—ã‚‡ã†ã€‚
                </p>
            </div>
        {/if}

        <!-- ã‚¨ãƒ‡ã‚£ã‚¿ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ãƒ¬ã‚¤ãƒ¤ãƒ¼ -->
        <div class="overlay-container">
            <EditorOverlay on:paste-multi-item={handlePasteMultiItem} />
        </div>
    </div>
</div>

<style>
.outliner {
    background: white;
    border: 1px solid #ddd;
    border-radius: 6px;
    overflow: hidden;
    margin-bottom: 20px;
    height: calc(100vh - 40px); /* ãƒ–ãƒ©ã‚¦ã‚¶ã®é«˜ã•ã‹ã‚‰ä½™ç™½ã‚’å¼•ã„ãŸå€¤ */
    display: flex;
    flex-direction: column;
}

.toolbar {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    padding: 8px 16px;
    background: #f5f5f5;
    border-bottom: 1px solid #ddd;
    flex-shrink: 0; /* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã¯ç¸®ã¾ãªã„ã‚ˆã†ã« */
}

.actions {
    display: flex;
    gap: 8px;
}

.actions button {
    background: #f0f0f0;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 4px 8px;
    cursor: pointer;
    font-size: 14px;
}

.actions button:hover {
    background: #e8e8e8;
}

.tree-container {
    padding: 8px 16px;
    position: relative; /* å­è¦ç´ ã®çµ¶å¯¾ä½ç½®ã®åŸºæº–ç‚¹ */
    min-height: 100px; /* æœ€å°é«˜ã•ã‚’è¨­å®š */
    flex: 1; /* æ®‹ã‚Šã®ç©ºé–“ã‚’å…¨ã¦ä½¿ç”¨ */
    overflow-y: auto; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯èƒ½ã« */
}

.item-container {
    position: absolute;
    left: calc(16px + max(0, var(--item-depth) - 1) * 24px);
    width: calc(100% - 32px - max(0, var(--item-depth) - 1) * 24px);
    min-height: 36px; /* æœ€å°ã®é«˜ã•ã‚’è¨­å®š */
    transition: left 0.2s ease, top 0.2s ease;
}

.empty-state {
    padding: 20px;
    text-align: center;
    color: #999;
}

.overlay-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none !important; /* ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä¸‹ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ç¢ºå®Ÿã«é€é */
    z-index: 100;
    transform: none !important; /* å¤‰å½¢ã‚’é˜²æ­¢ */
}
</style>
