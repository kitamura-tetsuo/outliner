name: Auto-link PR to Issues

on:
  pull_request:
    types: [opened, reopened, edited, synchronize]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  link-pr-to-issue:
    runs-on: self-hosted
    if: ${{ github.actor != 'dependabot[bot]' }}
    timeout-minutes: 10
    permissions:
      contents: read
      pull-requests: write
      issues: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Setup Git configuration
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "GitHub Actions Bot"
          echo "‚úÖ Git configuration set for Gemini CLI compatibility"

      - name: Setup Gemini CLI authentication
        run: |
          # Setup Gemini CLI for self-hosted runner
          echo "Setting up Gemini CLI authentication..."

          # Method 1: Check if persistent oauth_creds.json exists on runner
          if [ -f "/home/runner/.gemini/oauth_creds.json" ]; then
            echo "‚úÖ Found persistent Gemini CLI credentials at /home/runner/.gemini/oauth_creds.json"
            echo "Verifying credential file..."
            ls -la "/home/runner/.gemini/oauth_creds.json"
            echo "Gemini CLI is ready to use"
          elif [ -n "${{ secrets.GEMINI_API_KEY }}" ]; then
            # Method 2: Use API key if available
            echo "üîë Using Gemini API key for authentication..."
            # Set up API key authentication
            export GEMINI_API_KEY="${{ secrets.GEMINI_API_KEY }}"
            echo "‚úÖ Gemini CLI will use API key authentication"
          else
            echo "‚ùå No Gemini CLI credentials found. This is a critical error."
            echo "   Method 1 (Recommended for self-hosted): Run 'gemini auth login' on the runner machine"
            echo "   Method 2: Set GEMINI_API_KEY secret with API key"
            echo "   Available secrets (names only):"
            echo "   - GITHUB_TOKEN: $([ -n "${{ secrets.GITHUB_TOKEN }}" ] && echo "‚úÖ Available" || echo "‚ùå Missing")"
            echo "   - GEMINI_API_KEY: $([ -n "${{ secrets.GEMINI_API_KEY }}" ] && echo "‚úÖ Available" || echo "‚ùå Missing")"
            echo "   Failing workflow due to missing authentication..."
            exit 1
          fi
          
          # Install gemini-cli if not available
          if ! command -v gemini >/dev/null 2>&1; then
            echo "Installing gemini-cli..."
            npm install -g @google/gemini-cli || echo "Failed to install gemini-cli, continuing..."
          fi
          
          # Verify gemini-cli installation
          if command -v gemini >/dev/null 2>&1; then
            echo "Gemini CLI version: $(gemini --version 2>/dev/null || echo 'version check failed')"
          fi

      - name: Setup GitHub MCP server configuration
        run: |
          # Create or update Gemini CLI settings with GitHub MCP server
          mkdir -p "/home/runner/.gemini"

          # Create settings.json with GitHub MCP server
          cat > "/home/runner/.gemini/settings.json" << EOF
          {
            "theme": "Default Dark",
            "selectedAuthType": "oauth-personal",
            "checkpointing": {"enabled": true},
            "mcpServers": {
              "github": {
                "command": "npx",
                "args": ["-y", "@modelcontextprotocol/server-github"],
                "env": {
                  "GITHUB_PERSONAL_ACCESS_TOKEN": "${{ secrets.GITHUB_TOKEN }}"
                }
              }
            }
          }
          EOF

          chmod 600 "/home/runner/.gemini/settings.json"
          echo "‚úÖ GitHub MCP server configuration created"

      - name: Find related issues using Gemini CLI
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
          PR_AUTHOR: ${{ github.event.pull_request.user.login }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
          HOME: /home/runner
        run: |
          echo "üîç Analyzing PR #$PR_NUMBER to find related issues..."
          echo "PR Title: $PR_TITLE"
          echo "PR Author: $PR_AUTHOR"

          # Create a prompt for Gemini CLI to analyze the PR and find related issues
          cat > /tmp/gemini_prompt.txt << 'PROMPT_EOF'
          You are an expert GitHub issue analyzer with access to GitHub MCP server tools. Your task is to find issues related to a specific Pull Request through comprehensive analysis.

          PR Information:
          - Number: $PR_NUMBER
          - Title: $PR_TITLE
          - Author: $PR_AUTHOR
          - Repository: $REPO_OWNER/$REPO_NAME

          PR Description:
          $PR_BODY

          Analysis Strategy - Use GitHub MCP server tools to perform:

          1. **Repository Connection**: Connect to repository $REPO_OWNER/$REPO_NAME using GitHub MCP server

          2. **Comprehensive Issue Search**: Search both open and closed issues using multiple approaches:
             a) **Keyword-based search**: Extract key terms from PR title and description
             b) **Direct reference detection**: Look for explicit issue references (#123, fixes #456, etc.)
             c) **Component analysis**: Identify affected components from PR content
             d) **Semantic matching**: Find issues with similar functionality or problem domains

          3. **Relationship Analysis**: For each potential match, determine:
             - **fixes/closes**: PR completely resolves the issue (look for resolution keywords)
             - **related**: PR addresses similar functionality or is contextually connected
             - **references**: PR mentions or builds upon the issue

          4. **Quality Assessment**: Only include issues with:
             - Clear technical or functional relationship to PR changes
             - Relevant keyword overlap or component connection
             - Logical connection between issue problem and PR solution

          5. **Structured Output**: Return findings as valid JSON:
          {
            "related_issues": [
              {
                "issue_number": 123,
                "relationship": "fixes|closes|related",
                "reason": "Specific explanation with evidence from PR and issue content"
              }
            ]
          }

          **Critical Instructions**:
          - Use GitHub MCP server tools extensively for thorough issue searching
          - Search both open AND closed issues for comprehensive coverage
          - Prioritize precision - only include clearly related issues with strong evidence
          - Provide specific, evidence-based reasons for each relationship
          - Return empty array if no clear relationships found: {"related_issues": []}
          - Focus on analysis only - do NOT modify PR or issues

          Begin comprehensive analysis using GitHub MCP server tools.
          PROMPT_EOF

          # Replace environment variables in the prompt
          envsubst < /tmp/gemini_prompt.txt > /tmp/gemini_prompt_final.txt

          echo "üìù Generated prompt for Gemini CLI:"
          echo "----------------------------------------"
          cat /tmp/gemini_prompt_final.txt
          echo "----------------------------------------"

          # Run Gemini CLI with the prompt
          echo "ü§ñ Running Gemini CLI to find related issues..."

          # Change to /tmp directory to avoid Git repository issues
          cd /tmp

          # Debug: Check if Gemini CLI is available and configured
          echo "üîç Checking Gemini CLI availability..."
          if command -v gemini >/dev/null 2>&1; then
            echo "‚úÖ Gemini CLI found"
            gemini --version || echo "‚ö†Ô∏è Could not get Gemini CLI version"

            # Check configuration
            echo "üîç Checking Gemini CLI configuration..."
            echo "HOME environment variable: $HOME"
            ls -la "/home/runner/.gemini/" || echo "‚ö†Ô∏è No .gemini directory found"

            # Test authentication with a simple prompt (skip Git operations)
            echo "üîç Testing Gemini CLI authentication..."
            cd /tmp  # Use /tmp to avoid Git repository issues
            echo "test" | timeout 30 gemini --prompt "Respond with 'AUTH_TEST_OK' if you can read this." 2>&1 | tee /tmp/auth_test.log

            if grep -q "AUTH_TEST_OK" /tmp/auth_test.log; then
              echo "‚úÖ Gemini CLI authentication test successful"
            else
              echo "‚ùå Gemini CLI authentication test failed"
              echo "Auth test output:"
              cat /tmp/auth_test.log

              # Check for specific authentication errors (ignore Git errors)
              if grep -q "Code Assist login required\|authentication\|oauth" /tmp/auth_test.log && ! grep -q "GitError\|git config" /tmp/auth_test.log; then
                echo "‚ùå Authentication failure detected in test"
                exit 1
              elif grep -q "GitError\|git config" /tmp/auth_test.log; then
                echo "‚ö†Ô∏è Git configuration issue detected, but authentication may be working"
              fi
            fi

            # Run Gemini CLI with the prompt
            echo "üöÄ Executing Gemini CLI with 300 second timeout..."
            echo "üìù Prompt size: $(wc -c < /tmp/gemini_prompt_final.txt) characters"

            # Execute with extended timeout for comprehensive analysis
            timeout 300 gemini chat --prompt "$(cat /tmp/gemini_prompt_final.txt)" 2>&1 | tee /tmp/gemini_output.log
            GEMINI_EXIT_CODE=$?

            if [ $GEMINI_EXIT_CODE -eq 124 ]; then
              echo "‚è∞ Gemini CLI execution timed out after 300 seconds"
              echo "This may indicate complex analysis or network issues"
            elif [ $GEMINI_EXIT_CODE -ne 0 ]; then
              echo "‚ö†Ô∏è Gemini CLI execution failed with exit code: $GEMINI_EXIT_CODE"
              echo "üìã Output log content:"
              cat /tmp/gemini_output.log || echo "No output log available"
              echo "üîç Possible causes:"
              echo "  - Authentication issues (check OAuth credentials)"
              echo "  - Network connectivity problems"
              echo "  - GitHub MCP server configuration issues"
              echo "  - API rate limiting"
            fi

            # Handle failure cases
            if [ $GEMINI_EXIT_CODE -ne 0 ]; then
              echo "‚ùå Gemini CLI execution failed - this is a critical error"
              echo "Creating empty result due to Gemini CLI failure..."
              echo '{"related_issues":[]}' > /tmp/related_issues.json
              exit 1  # Fail the workflow for authentication/execution issues
            fi

            echo "‚úÖ Gemini CLI execution completed"
            echo "Output:"
            cat /tmp/gemini_output.log || echo "No output log available"

            # Extract JSON from Gemini output with improved parsing
            echo "üîç Extracting JSON from Gemini output..."
            echo "üìä Output size: $(wc -c < /tmp/gemini_output.log) characters"

            # Show last 20 lines of output for debugging
            echo "üìã Last 20 lines of Gemini output:"
            echo "===================="
            tail -20 /tmp/gemini_output.log
            echo "===================="

            # Multiple JSON extraction strategies
            JSON_EXTRACTED=false

            # Strategy 1: Look for complete JSON with related_issues
            if grep -o '{[^{}]*"related_issues"[^{}]*}' /tmp/gemini_output.log > /tmp/related_issues.json 2>/dev/null; then
              echo "‚úÖ Strategy 1: Found JSON with related_issues"
              JSON_EXTRACTED=true
            # Strategy 2: Look for multiline JSON
            elif sed -n '/{/,/}/p' /tmp/gemini_output.log | grep -q "related_issues"; then
              sed -n '/{/,/}/p' /tmp/gemini_output.log > /tmp/related_issues.json
              echo "‚úÖ Strategy 2: Found multiline JSON"
              JSON_EXTRACTED=true
            # Strategy 3: Look for any JSON structure and validate
            elif grep -o '{.*}' /tmp/gemini_output.log | tail -1 > /tmp/temp_json.txt 2>/dev/null; then
              if grep -q "related_issues" /tmp/temp_json.txt; then
                cp /tmp/temp_json.txt /tmp/related_issues.json
                echo "‚úÖ Strategy 3: Found JSON with alternative method"
                JSON_EXTRACTED=true
              fi
              rm -f /tmp/temp_json.txt
            fi

            # Fallback to empty result - but check if this was due to authentication failure
            if [ "$JSON_EXTRACTED" = false ]; then
              echo "‚ö†Ô∏è Could not extract valid JSON from Gemini output"

              # Check if the output contains authentication errors
              if grep -q "Code Assist login required\|authentication\|oauth" /tmp/gemini_output.log; then
                echo "‚ùå Authentication failure detected in Gemini CLI output"
                echo "This indicates OAuth credentials are not properly configured"
                exit 1  # Fail the workflow for authentication issues
              fi

              echo "Creating empty result..."
              echo '{"related_issues": []}' > /tmp/related_issues.json
            fi

            # Validate JSON structure
            if ! jq empty /tmp/related_issues.json 2>/dev/null; then
              echo "‚ö†Ô∏è Invalid JSON detected, creating empty result"
              echo '{"related_issues": []}' > /tmp/related_issues.json
            fi
          else
            echo "‚ùå Gemini CLI not available"
            echo "Please ensure Gemini CLI is properly installed and configured"
            # Create empty result file but fail the workflow
            echo '{"related_issues": []}' > /tmp/related_issues.json
            exit 1  # Fail the workflow when Gemini CLI is not available
          fi

          echo "üìÑ Related issues found:"
          cat /tmp/related_issues.json

          # Clean up temporary files
          rm -f /tmp/gemini_prompt.txt /tmp/gemini_prompt_final.txt

      - name: Install required tools
        run: |
          # Install jq if not available
          if ! command -v jq >/dev/null 2>&1; then
            echo "Installing jq..."
            sudo apt update
            sudo apt install jq -y
          fi

          # Install GitHub CLI if not available
          if ! command -v gh >/dev/null 2>&1; then
            echo "Installing GitHub CLI..."
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt update
            sudo apt install gh -y
          fi

          # Verify installations
          jq --version
          gh --version

      - name: Update PR description with issue links using GitHub CLI
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          echo "üîó Updating PR description with issue links..."

          # Check if related issues file exists
          if [ ! -f /tmp/related_issues.json ]; then
            echo "‚ö†Ô∏è No related issues file found, skipping PR update"
            exit 0
          fi

          # Read the related issues JSON
          RELATED_ISSUES=$(cat /tmp/related_issues.json)
          echo "Related issues data: $RELATED_ISSUES"

          # Validate JSON format
          echo "üîç Validating JSON format..."
          if ! echo "$RELATED_ISSUES" | jq . >/dev/null 2>&1; then
            echo "‚ùå Invalid JSON format detected"
            echo "Raw content:"
            cat /tmp/related_issues.json
            echo "Creating empty result..."
            echo '{"related_issues": []}' > /tmp/related_issues.json
            RELATED_ISSUES='{"related_issues": []}'
          fi

          # Check if there are any related issues
          ISSUE_COUNT=$(echo "$RELATED_ISSUES" | jq '.related_issues | length' 2>/dev/null || echo "0")

          if [ "$ISSUE_COUNT" -eq 0 ]; then
            echo "‚ÑπÔ∏è No related issues found, no PR update needed"
            exit 0
          fi

          echo "üìä Found $ISSUE_COUNT related issue(s)"

          # Debug: Show each issue
          echo "üîç Issue details:"
          echo "$RELATED_ISSUES" | jq '.related_issues[]' 2>/dev/null || echo "Could not parse issues"

          # Get current PR description
          echo "üì• Getting current PR description..."
          CURRENT_BODY=$(gh pr view $PR_NUMBER --repo $REPO_OWNER/$REPO_NAME --json body --jq '.body')

          # Build linking keywords
          echo "üîó Building linking keywords..."
          LINKING_KEYWORDS=""

          # Process each related issue and build linking keywords
          LINKING_KEYWORDS_FILE="/tmp/linking_keywords.txt"
          > "$LINKING_KEYWORDS_FILE"  # Clear file

          echo "$RELATED_ISSUES" | jq -r '.related_issues[] | "\(.issue_number)|\(.relationship)|\(.reason)"' 2>/dev/null | while IFS='|' read -r issue_num relationship reason; do
            if [ -n "$issue_num" ]; then
              case "$relationship" in
                "fixes"|"closes")
                  KEYWORD="Fixes #$issue_num"
                  ;;
                "related")
                  KEYWORD="Related to #$issue_num"
                  ;;
                *)
                  KEYWORD="Related to #$issue_num"
                  ;;
              esac

              echo "Processing: $KEYWORD ($reason)"

              # Check if this linking keyword already exists in the PR description
              if echo "$CURRENT_BODY" | grep -q "$KEYWORD"; then
                echo "‚ö†Ô∏è Link '$KEYWORD' already exists in PR description"
              else
                echo "$KEYWORD" >> "$LINKING_KEYWORDS_FILE"
              fi
            fi
          done

          # Check if we have new linking keywords to add
          if [ -s "$LINKING_KEYWORDS_FILE" ]; then
            echo "üìù Adding linking keywords to PR description..."

            # Create new PR body with linking keywords
            {
              echo "$CURRENT_BODY"
              echo ""
              echo "## Related Issues"
              echo ""
              cat "$LINKING_KEYWORDS_FILE"
            } > /tmp/new_pr_body.txt

            # Debug: Show what we're about to add
            echo "üîç Keywords to add:"
            cat "$LINKING_KEYWORDS_FILE"

            # Create new PR body by combining current body with linking keywords
            echo "üîç Creating new PR body..."

            # Create temporary file for new body
            {
              echo "$CURRENT_BODY"
              echo ""
              echo "## Related Issues"
              echo ""
              cat "$LINKING_KEYWORDS_FILE"
            } > /tmp/new_pr_body.txt

            # Debug: Show the new body preview
            echo "üîç New PR body preview (first 20 lines):"
            echo "========================"
            head -20 /tmp/new_pr_body.txt
            echo "========================"

            # Update PR description using GitHub CLI with improved error handling
            echo "üöÄ Updating PR description..."
            echo "üìä New body size: $(wc -c < /tmp/new_pr_body.txt) characters"

            # Validate GitHub CLI authentication
            if ! gh auth status >/dev/null 2>&1; then
              echo "‚ùå GitHub CLI authentication failed"
              echo "Please check GITHUB_TOKEN configuration"
              exit 1
            fi

            # Try using file method first (more reliable for large content)
            echo "üîÑ Attempting file-based update..."
            if gh pr edit $PR_NUMBER --repo $REPO_OWNER/$REPO_NAME --body-file /tmp/new_pr_body.txt 2>/dev/null; then
              echo "‚úÖ PR description updated successfully using file method"
            else
              echo "‚ö†Ô∏è File method failed, trying direct content method..."

              # Try reading file content and using direct body parameter
              NEW_BODY_CONTENT=$(cat /tmp/new_pr_body.txt)
              BODY_SIZE=${#NEW_BODY_CONTENT}
              echo "üìä Content size: $BODY_SIZE characters"

              if [ $BODY_SIZE -gt 65536 ]; then
                echo "‚ö†Ô∏è Content too large ($BODY_SIZE chars), truncating..."
                NEW_BODY_CONTENT=$(echo "$NEW_BODY_CONTENT" | head -c 65000)
                echo "..." >> /tmp/truncated_body.txt
                NEW_BODY_CONTENT="$NEW_BODY_CONTENT..."
              fi

              if gh pr edit $PR_NUMBER --repo $REPO_OWNER/$REPO_NAME --body "$NEW_BODY_CONTENT" 2>/dev/null; then
                echo "‚úÖ PR description updated successfully using direct method"
              else
                echo "‚ùå All update methods failed"
                echo "üîç Debugging information:"
                echo "  - PR Number: $PR_NUMBER"
                echo "  - Repository: $REPO_OWNER/$REPO_NAME"
                echo "  - Body size: $BODY_SIZE characters"
                echo "  - GitHub CLI version: $(gh --version | head -1)"
                echo "‚ö†Ô∏è Continuing workflow without failing (non-critical error)"
                exit 0  # Don't fail the workflow for PR update issues
              fi
            fi

            echo "Added linking keywords:"
            cat "$LINKING_KEYWORDS_FILE"

            # Clean up
            rm -f /tmp/new_pr_body.txt "$LINKING_KEYWORDS_FILE"
          else
            echo "‚ÑπÔ∏è No new issue links to add"
            rm -f "$LINKING_KEYWORDS_FILE"
          fi

      - name: Cleanup
        if: always()
        run: |
          echo "üßπ Cleaning up temporary files..."
          rm -f /tmp/gemini_prompt*.txt
          echo "‚úÖ Cleanup completed"

      - name: Log failure information
        if: failure()
        run: |
          echo "ü§ñ PR Issue Linking Failed"
          echo ""
          echo "The automated PR-to-issue linking process encountered an error."
          echo "This could be due to:"
          echo "- Gemini CLI authentication issues"
          echo "- GitHub MCP server configuration problems"
          echo "- Network connectivity issues"
          echo ""
          echo "Manual Action Required:"
          echo "Please manually review this PR and link any related issues using the format:"
          echo "- 'Fixes #issue_number' (to close the issue when PR is merged)"
          echo "- 'Related to #issue_number' (to reference without closing)"
          echo ""
          echo "Add these keywords to the PR description to automatically link issues"
          echo "in GitHub's 'Development' section."
