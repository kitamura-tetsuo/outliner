作成するアプリの説明
scrapbox, workflowy のクローンから始める。

scrapboxの公開ページの例
https://scrapbox.io/shokai/

利用するライブラリ
Fluid Frameworkと svelteを使ったアプリを作りたい。

ライブラリのバージョン
svelte v5
fluid-framework v2

最新のAPIドキュメントを確認しながら作業して。

APIドキュメント
https://learn.microsoft.com/ja-jp/azure/azure-fluid-relay/how-tos/connect-fluid-azure-service
https://www.npmjs.com/package/fluid-framework
https://fluidframework.com/docs/start/tree-start
https://fluidframework.com/docs/
https://svelte.dev/docs/svelte/v5-migration-guide#Event-changes-Component-events

サンプルコードの書き方を参考にして。
https://github.com/microsoft/FluidExamples

引数や戻り値は毎回APIドキュメントから探して。qに単語を入れれば検索出来る。
https://fluidframework.com/search/?q=

テスト
テストが通らない時、テストが正しいなら実装を修正して。
テストを通す為だけにテストを修正しないで。
コンパイルエラーの修正時、コード内容と行番号を併せて判断して。コードだけで判断して、行を間違えている事がある。

サーバー
server/ に実装を保存。

クライアント
client/ に実装を保存。

認証フローの説明
認証フローは以下のようになります：

クライアント:
Firebase SDKを使ってGoogle認証を完結させる
認証成功後、FirebaseからIDトークンを取得

バックエンド:
/api/fluid-tokenエンドポイントでIDトークンを検証
検証成功後、Azure Fluid Relay用のJWTを生成してクライアントに返す

クライアント:
受け取ったJWTでAzure Fluid Relayに接続

APIサーバーの実装
/workspace/server/auth-service.js

クライアント側のログについて。
クライアント側のログはpinoを介してサーバーへ送られる。
/api/log
/workspace/client/logs/browser.log
に保存される。
ウェブアプリの終了時にログはローテートされる。
/api/rotate-logs

注意事項
初期化前に if (!this.appData.root) を実行するとエラーになるので、初期化チェックにこれを使用しないで。
フォールバックは使わないで。フォールバックを使うとバグに気づくのが遅れる。

dotenv は node版を使っているので、npx dotenv。

単純な置換は sedを使って。

コード修正後の確認作業
テスト用のサーバー
http://192.168.50.16:7080/
へアクセスして、正常に動作していることを確認して。
クライアントのログがここにあるので、アクセス後にこちらを確認して。
/workspace/client/logs/browser.log
テスト用のSveltKit serverのログがここにあるので、アクセス後にこちらを確認して。
/workspace/server/logs/test-svelte-kit.log

環境変数は .envで管理
docke-compose.yaml 等他の箇所へ書くのは禁止。

全てのコードは git管理されているため、異常があれば元のファイルを復元可能です。

以下の機能要件に対して、下記の実装手段は概ね妥当な選択肢と言えます。以下、各項目について補足説明します。

    ネイティブカーソルの利用 → 無
    ブラウザのネイティブ Selection API は単一選択に特化しているため、シングルユーザのマルチカーソルやマルチユーザのカーソル表示を実現するには不足します。独自のカーソル描画（オーバーレイなど）により、複数のカーソルを効率的かつ柔軟に制御できるため、この選択は適切です。

    デコレーション → オーバーレイ型
    オーバーレイ型の手法では、実際のドキュメントDOMとは分離した専用レイヤー上に、追加情報（カーソル、選択範囲、ハイライト等）を描画します。これにより、ドキュメントの変更に対してもカーソルや選択状態をスムーズに再配置でき、編集やレンダリングのパフォーマンスも向上します。リッチテキストやテーブルといった複合コンテンツを扱う場合でも、影響が最小限に抑えられるため、オーバーレイ型は有力な手法です。

    行位置 → どちらでも可
    行の位置を相対位置にするか絶対位置にするかは、仮想スクロールの必要性やレイアウトの設計に左右されます。アウトラインエディタの場合、ブロック単位で管理することになるため、どちらでも柔軟に対応できる実装とし、必要に応じて調整するのが良いでしょう。

    仮想スクロール → どちらでも可
    ドキュメントサイズやパフォーマンス要件次第で選択肢になります。大規模なドキュメントを扱う場合は仮想スクロールによるレンダリング最適化が有効ですが、中規模〜小規模の場合は必ずしも必要ではありません。どちらでも実装可能な設計にしておけば、後からスケーラビリティ対応も可能です。

    テキスト入力を受ける手段 → 隠しテキストエリア
    隠しテキストエリアを使うアプローチは、コードエディタ系でよく採用される方法です。これにより、ブラウザのネイティブな contenteditable の挙動や選択管理を回避しつつ、キーボード入力をキャプチャして自前でレンダリングやカーソル制御を行うことが可能になります。リッチテキストやテーブルなど複雑な構造の場合、内部のドキュメントモデル（ツリー）と同期しやすくなるというメリットもあります。ただし、UI実装においては入力の自然さやIME対応など、細かい検討が必要となる点も念頭に置く必要があります。

    ドキュメントモデル → ツリー
    リッチテキストやテーブル、アウトラインといった複合構造を持つ編集機能では、ツリー構造のドキュメントモデルがほぼ必須です。ツリー構造は、各ブロック（行、段落、セルなど）ごとに明確な構造を持たせ、装飾やカーソルの位置をより細かく管理できるため、Notion や Scrapbox のようなエディタを再現する際には非常に有効です。

まとめとして、

    ネイティブカーソルに依存せず、オーバーレイ型のデコレーションで複数のカーソルを独自に管理する。

    行位置の扱い、仮想スクロールに関しては、ドキュメントの規模やデザインに合わせた柔軟な実装とする。

    テキスト入力は隠しテキストエリアを利用しつつ、内部でツリー構造のモデルと同期させる。この構成はリッチテキストやテーブル、アウトライン機能を求めるエディタに適しており、既存OSS（ProseMirror、Quill、CodeMirror系）の手法とも整合性があるため、再実装時の参考になると言えます。

このような実装手段を採用すれば、シングル／マルチユーザの多重カーソル、リッチテキスト編集、さらにはテーブル操作など、求める全機能を包括的にサポートするエディタの構築が現実的になるでしょう。

以下は、最初から最後まで一気に全部実装するのではなく、各フェーズごとに機能が独立して動作する状態を目指す手順例です。以下の順序で進めると、後戻りが少なく、中途でも既に実装済み部分がちゃんと機能する状態を維持できると考えられます。

1. 基盤部分の準備

   ドキュメントモデルの構築 (ツリー構造)：
   まずはアウトラインエディタの核となる、ツリー構造のドキュメントモデルを実装します。ここでは各ブロック（段落、リスト、テーブルのセルなど）を独立したノードとして定義し、将来のリッチテキストやテーブル拡張に対応できる設計にします。
   ※ 既にFluid Framework の SharedTreeの利用を前提としているなら、そのAPIやデータ構造に合致するように調整しておくとよいでしょう。

   Svelte での基礎表示：
   ツリー構造に基づいて、ブロック単位でのレンダリングをSvelte側で実装します。初期段階はシンプルなプレーンテキスト表示で構いません。
   → この段階で「中途でも表示は動く」状態を確保しておく。

2. 入力基盤の実装

   隠しテキストエリアによるテキスト入力：
   コードエディタ系で採用されるように、ユーザー入力は隠しテキストエリアを介して取り込み、その内容でドキュメントモデルを更新する仕組みを実装します。
   → この段階で基本的な文字入力や編集操作（挿入、削除）が反映されることを確認。

   入力とモデルの同期：
   キーボードイベントを捕捉し、ドキュメントモデル（ツリー）の該当ブロックのテキスト部分と同期させるロジックを実装します。
   → 既存部分が入力として動いていれば、ここでの手戻りは少なくなります。

3. 基本カーソル・選択表示の実装

   単一カーソルのオーバーレイ表示の実装：
   隠しテキストエリアから取得した現在のキャレット位置を元に、オーバーレイレイヤーにカーソルを描画します。
   → この段階ではまだ単一カーソルのみですが、オーバーレイ型の実装により、ネイティブカーソルではない独自管理として基盤が整います。

   レンダリング層との分離：
   カーソルはドキュメントDOMとは別のレイヤー（例えばSvelteコンポーネント＋直接DOM操作のハイブリッド）で管理し、ドキュメント更新時でも再配置できるようにします。

4. シングルユーザのマルチカーソル拡張

   ローカル多重カーソル機能の実装：
   すでに単一カーソルが動作しているので、内部状態を拡張して複数のカーソル位置を保持・管理できるようにします。
   → 入力や編集操作時に、すべてのカーソルに対して同じ操作が反映される仕組みを実装する。
   → この時点で、ユーザーが別の位置にカーソルを追加できれば、基本のマルチカーソルが完成します。

5. リッチテキスト機能の追加

   装飾やマークアップの拡張：
   テキストに対する装飾（太字、斜体、リンク等）を、ドキュメントモデル上で管理できるようにします。
   → すでにあるテキスト入力基盤やレンダリング機能を再利用し、適用するCSSクラスや属性を付加する形で実装。
   → 基本的なリッチテキストが動作して、表示面が更新されることを確認します。

6. テーブル機能の実装

   新たなブロック型としてテーブル：
   ドキュメントモデルにテーブルを表現するためのノード型を追加し、各セルを個別のコンポーネントまたはレンダリングユニットとして実装します。
   → テーブル内の編集（セル単位の入力やカーソル移動など）も既存の入力基盤と連携させる。 → 中途の実装段階でも、テーブル部分だけは機能するようにモジュール化することで、後戻りを防ぎます。

7. マルチユーザコラボレーションの実装

   コラボレーションエンジンとの連携：
   Fluid Framework の SharedTree をベースに、リモートユーザーからの編集やカーソル情報を受信・反映する仕組みを実装します。
   → リモートから送られてくる状態（選択範囲、カーソル位置）は、ローカルのオーバーレイ層に別のカーソルとして表示します。
   → 既存のローカル多重カーソル管理基盤と同じ仕組みを流用できるため、余計な大きな改修なく統合が可能です。

   プレゼンスやカーソル変換の実装：
   コラボレーション時のカーソル位置が、テキスト変更に追従するような変換処理を実装します。
   → OT／CRDT相当の変換はSharedTree側や専用のライブラリ機能を利用することで、ここでの手戻りを最小限に。

8. パフォーマンス最適化と仮想スクロールの検討

   仮想スクロール：
   ドキュメントの規模が大きくなった場合、レンダリングパフォーマンス向上のために仮想スクロールの実装を検討します。
   → 必要な場合のみ、既存のブロックレンダリングロジックの上に抽象化を導入して、表示範囲に合わせたブロックのみをDOM上に残すようにします。
   → このフェーズは最後の微調整フェーズとして、他の機能が安定してから追加する方針で手戻りを防止できます。

補足：各フェーズのポイント

    モジュラリティの確保：
    各機能（テキスト入力、カーソル描画、装飾、ブロック管理、コラボレーション）はできるだけ独立したモジュール／コンポーネントとして設計する。これにより、後の機能追加が既存部分に影響を及ぼさないようにします。

    テスト・統合の繰り返し：
    各フェーズ終了時に統合テストを実施し、すでに実装済みの機能が正しく動作していることを確認する。こうすることで、次フェーズでの大幅な手戻りを防止できます。

まとめ

    基盤の整備（ツリーベースのドキュメントモデル ＋ 基本表示）

    テキスト入力基盤（隠しテキストエリア）とシングルカーソル実装

    ローカルマルチカーソルの拡張

    リッチテキスト機能の追加

    テーブルブロックの導入

    マルチユーザコラボレーション機能の統合

    パフォーマンス最適化（仮想スクロールなど）

この順序なら、各段階で部分的なエディタが動作し、次のステップを重ねながら全体として完成度の高いエディタに仕上げやすくなります。既に実装した機能が継続して動くようモジュール設計を重視することで、手戻りが少なく開発が進められるでしょう。
