# ğŸ“„ Documentation & Specifications

Record end-user features as individual YAML files in docs/client-features/<slug>-<title>-<8-char-uuid>.yaml. The <slug> must be exactly three alphabetical characters derived from the feature ID prefix.
Each feature YAML must contain both an English title (`title`) and its Japanese translation (`title-ja`).
docs/client-features.yaml is auto-generated by aggregating these files.
Development and environment maintenance features (the ENV-* series) are stored in docs/dev-features/<slug>-<title>-<8-char-uuid>.yaml files. docs/dev-features.yaml is auto-generated by aggregating these files.
Document intentionally omitted features in docs/unimplemented-features.md.

- While multiple AIs may code in parallel, review documents frequently to avoid overlapping features or contradictory explanations.
- Continuously reference and update past best practices so they remain current.
- Keep the implementation plan documentation updated whenever changes occur.
  docs/feature-map.md is automatically generated; do not edit it.

# ğŸ§ª Test implementation and execution policy

## ãƒ†ã‚¹ãƒˆã®ç¶²ç¾…æ€§ã¨ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆã®æ´»ç”¨

æ–°ã—ã„æ©Ÿèƒ½ã‚’è¿½åŠ ã¾ãŸã¯æ—¢å­˜ã®æ©Ÿèƒ½ã‚’å¤‰æ›´ã™ã‚‹éš›ã«ã¯ã€ãã®å¤‰æ›´ãŒåºƒç¯„å›²ã«å½±éŸ¿ã‚’åŠã¼ã™å¯èƒ½æ€§ã‚’è€ƒæ…®ã—ã€ååˆ†ãªãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ã‚’ç¢ºä¿ã™ã‚‹ã‚ˆã†åŠªã‚ã¦ãã ã•ã„ã€‚

- **ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆã®ç¢ºèª**: ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆå®Ÿè¡Œå¾Œã«ç”Ÿæˆã•ã‚Œã‚‹ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆï¼ˆ`coverage/unit_and_integration/index.html`ãªã©ï¼‰ã‚’å¿…ãšç¢ºèªã—ã¦ãã ã•ã„ã€‚
- **ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã®è¿½åŠ **: ã‚«ãƒãƒ¬ãƒƒã‚¸ãŒä½ã„ç®‡æ‰€ã‚„ã€æ–°ãŸã«è¿½åŠ ãƒ»å¤‰æ›´ã•ã‚ŒãŸãƒ­ã‚¸ãƒƒã‚¯ã§ãƒ†ã‚¹ãƒˆã•ã‚Œã¦ã„ãªã„ç®‡æ‰€ã‚’ç‰¹å®šã—ã€å¿…è¦ãªãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚ç‰¹ã«æ¡ä»¶åˆ†å²ã‚„ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ãŒç¶²ç¾…ã•ã‚Œã¦ã„ã‚‹ã‹æ³¨æ„æ·±ãç¢ºèªã—ã¾ã™ã€‚
- **æ—¢å­˜ãƒ†ã‚¹ãƒˆã®æ‹¡å……**: å˜ã«æ–°ã—ã„ãƒ†ã‚¹ãƒˆã‚’è¿½åŠ ã™ã‚‹ã ã‘ã§ãªãã€æ—¢å­˜ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ãŒæ–°ã—ã„æ©Ÿèƒ½ã‚„å¤‰æ›´ç‚¹ã‚’è€ƒæ…®ã—ãŸã‚‚ã®ã«ãªã£ã¦ã„ã‚‹ã‹ã‚’è¦‹ç›´ã—ã€å¿…è¦ã«å¿œã˜ã¦æ‹¡å……ã—ã¦ãã ã•ã„ã€‚
  ç›®æ¨™ã¯ã€ã‚³ãƒ¼ãƒ‰ã®å“è³ªã¨å®‰å®šæ€§ã‚’ç¶­æŒã™ã‚‹ãŸã‚ã«ã€ãƒ†ã‚¹ãƒˆã«ã‚ˆã£ã¦ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã®å¤§éƒ¨åˆ†ãŒæ¤œè¨¼ã•ã‚Œã¦ã„ã‚‹çŠ¶æ…‹ã‚’ä¿ã¤ã“ã¨ã§ã™ã€‚

For every feature, create a corresponding test.
Make the expected values â€‹â€‹used for pass/fail judgments strict; longer test-execution time is acceptable if that is the consequence.
Do not embed code that skips tests.
Do not use mocks in tests.
Run tests in headless mode.
Fix one test file at a time and run tests after each fix to confirm.
Run environment maintenance tests (ENV-*) separately from unit and e2e suites.
These tests use Vitest while e2e tests use Playwright.

## ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã«ãŠã‘ã‚‹ãƒ¢ãƒƒã‚¯ã¨ãƒ†ã‚¹ãƒˆãƒ€ãƒ–ãƒ«ã®ä½¿ç”¨ã«ã¤ã„ã¦

åŸå‰‡ã¨ã—ã¦ãƒ¢ãƒƒã‚¯ã¯ä½¿ç”¨ã—ã¾ã›ã‚“ãŒã€ä»¥ä¸‹ã®ã‚±ãƒ¼ã‚¹ã«ãŠã„ã¦ã¯é™å®šçš„ãªä½¿ç”¨ã‚’è¨±å®¹ã—ã¾ã™ã€‚

- **Svelteã‚¹ãƒˆã‚¢**: ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆå¯¾è±¡ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒSvelteã‚¹ãƒˆã‚¢ã«ä¾å­˜ã—ã¦ã„ã‚‹å ´åˆã€ã‚¹ãƒˆã‚¢ã®æŒ™å‹•ã‚’åˆ¶å¾¡ã™ã‚‹ãŸã‚ã« `vi.mock` ã‚’ä½¿ç”¨ã—ã¦ã‚¹ãƒˆã‚¢ã®é–¢æ•°ã‚„ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ãƒ¢ãƒƒã‚¯ã™ã‚‹ã“ã¨ã‚’è¨±å®¹ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã‚¹ãƒˆã‚¢ã®çŠ¶æ…‹ã‚„ã‚¹ãƒˆã‚¢çµŒç”±ã§ã®å‰¯ä½œç”¨ã‚’ãƒ†ã‚¹ãƒˆãƒ€ãƒ–ãƒ«ã§ç½®ãæ›ãˆã€ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã®åˆ†é›¢æ€§ã‚’é«˜ã‚ã¾ã™ã€‚
  - ä½¿ç”¨ä¾‹: `vi.mock('../stores/editorOverlayStore.svelte', () => ({ editorOverlayStore: { subscribe: vi.fn(), update: vi.fn(), set: vi.fn(), getTextareaRef: vi.fn(() => mockTextareaElement), /* ä»–ã®ã‚¹ãƒˆã‚¢ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚„é–¢æ•° */ } }));`
- **Fluid Framework `Item` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ**: `Item`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚ˆã†ãªè¤‡é›‘ãªå¤–éƒ¨ä¾å­˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã¯ã€ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã®å®Ÿè¡ŒåŠ¹ç‡ã¨åˆ†é›¢æ€§ã‚’è€ƒæ…®ã—ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æº€ãŸã™å˜ç´”ãªãƒ†ã‚¹ãƒˆãƒ€ãƒ–ãƒ«ï¼ˆã‚¹ã‚¿ãƒ–ï¼‰ã®ä½¿ç”¨ã‚’è¨±å®¹ã—ã¾ã™ã€‚ãƒ†ã‚¹ãƒˆãƒ€ãƒ–ãƒ«ã¯ã€ãƒ†ã‚¹ãƒˆå¯¾è±¡ã®ãƒ­ã‚¸ãƒƒã‚¯ãŒå¿…è¦ã¨ã™ã‚‹æœ€å°é™ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ï¼ˆä¾‹: `text`, `id`ï¼‰ã¨ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆä¾‹: `updateText`ï¼‰ã‚’æŒã¤ã¹ãã§ã™ã€‚
  - ä½¿ç”¨ä¾‹: `const mockItem = { id: 'test-item', text: 'initial text', updateText: vi.fn((newText) => { mockItem.text = newText; }), items: { /* å­ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ¢ãƒƒã‚¯ãªã© */ } };`

ã“ã‚Œã‚‰ã®ãƒ¢ãƒƒã‚¯ã‚„ãƒ†ã‚¹ãƒˆãƒ€ãƒ–ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹éš›ã¯ã€ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰å†…ã§ãã®ç›®çš„ã¨ç¯„å›²ã‚’æ˜ç¢ºã«ã‚³ãƒ¡ãƒ³ãƒˆã—ã€éåº¦ãªãƒ¢ãƒƒã‚¯ã«ã‚ˆã£ã¦ãƒ†ã‚¹ãƒˆãŒå®Ÿè£…ã®è©³ç´°ã¨å¯†çµåˆã—ã™ããªã„ã‚ˆã†æ³¨æ„ã—ã¦ãã ã•ã„ã€‚E2Eãƒ†ã‚¹ãƒˆã§ã‚«ãƒãƒ¼ã•ã‚Œã‚‹ã¹ãçµ±åˆçš„ãªæŒ¯ã‚‹èˆã„ã‚’ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã§ç„¡ç†ã«å†ç¾ã—ã‚ˆã†ã¨ã—ãªã„ã§ãã ã•ã„ã€‚

# ğŸ” How to deal with test failures

Whenever you modify code or tests, always run the affected tests to verify the fix.
If a test fails, do not adjust the test to match the implementation. First confirm that the testâ€™s expectations align with the specification; if they do, fix the implementation.
ğŸŒ E2E tests & test environment
In E2E tests, do not assume that something â€œcannot run in the test environment.â€ If it fails, either adjust the implementation or prepare the environment so that it runs. When the cause of E2E failure is unclear, investigate with Playwright MCP.
Before concluding that the test server is not running, check with
((curl http://localhost:7090/) -join "n").Substring(0, 100) (limit to 100 characters).
If a specific test does not start, inspect the server log at server\logs\svelte-kit.log.

# ğŸ› ï¸ Code style & quality

Use undefined instead of null.
Do not create duplicate functions in multiple locations.
The use of page.waitForLoadState("networkidle"); is prohibited.
Process synchronously whenever possible.
Please write git branch names, commit messages, etc. in English.
Git branch names must be written in English.

# âš™ï¸ Development workflow

At the end of your work, create the first prompt for the next session so you can continue smoothly. Even if issues remain, carry over the known problems. Focus on writing a prompt that makes the next session effective rather than describing todayâ€™s work.
State in the prompt that tasks should be progressed sequentially.
Write the prompt as plain text.

# ğŸ“ Working Directory Management

**CRITICAL**: Always pay attention to the current working directory when executing commands.

- Client code is in `client`
- Server code is in `server`
- Scripts are in `scripts`
- Development environment tests (ENV-*) are in `scripts/tests`

When using launch-process tool:

- Always specify the correct `cwd` parameter for the intended directory
- Do not assume the current directory - explicitly set it
- For client tests: use `client` as cwd
- For ENV-* tests: use `scripts/tests` as cwd

Common mistakes to avoid:

- Running client commands from wrong directory
- Executing scripts without proper cwd specification
- Assuming terminal's current directory matches intended target

# âš¡ Performance & Reactivity

Ensure Svelte HTML elements update reactively.
Prefer patterns that update reactive variables asynchronously.
Prioritize performance.

# Testing Framework

- Tests should be documented in docs/client-features/<slug>-<title>-<8-char-uuid>.yaml with specific naming conventions (CLM-0100, SLR-0002, FMT-0001, etc.) and test files must use the same <slug>-<title>-<8-char-uuid> pattern.
- Tests should retrieve SharedTree content and cursor information in JSON format using treeValidation.ts and cursorValidation.ts, with real SharedTree data rather than mocks.
- For E2E tests, call TestHelpers.prepareTestEnvironment(page) in test.beforeEach and use Playwright's expect(locator).toBeVisible() pattern instead of manual DOM selection checks.
- For E2E tests that need to call client-side code, use page.evaluate through helper classes (like TestHelpers) rather than calling client code directly or writing page.evaluate inline in test files.
- Create projects and pages programmatically via fluidClient reference rather than through the UI which is unstable.
- When tests fail, prioritize fixing the implementation to match test expectations rather than modifying the tests.
- When tests fail due to navigation or functionality issues, fix the implementation or test method rather than just modifying tests to pass.
- For clipboard testing, use actual clipboard API operations which only work in HTTPS or localhost environments.
- Delete existing accessible containers before creating new test containers to ensure a clean test environment.
- User prefers fixing test files one by one with immediate test execution after each fix, and wants continuation prompts created at session end that focus on remaining issues rather than completed work.
- For cursor position testing, always use CursorValidator.getCursorData(page) instead of global-textarea cursor position, as they represent different things in the application.
- When Playwright tests show setup messages and then display test results with 'passed' status, the tests are executing successfully - don't assume execution problems based on setup warnings about emulator connections.
- When selecting items in tests, use data-item-id instead of index-based selection like .nth(1).
- User prefers absolute paths instead of 'cd client' commands, dislikes auto-opening browsers for HTML reports, and wants file output for test results but with proper encoding to prevent character corruption.
- For test execution, use the file output method with UTF-8 encoding to avoid character corruption, and never use nth() for element selection in tests - use data-item-id or other specific selectors instead.
- For link testing, first test within current project, verify new page creation in fluid container data before testing links, and create helper functions for data verification if they don't exist.
- When Playwright test output cannot be read directly, use cmd /c with output redirection to save results to a file and then read the file: cmd /c "cd /d path && npm run test:e2e ... > test-output.txt 2>&1 && type test-output.txt"
- When terminal output cannot be retrieved properly, it causes repeated dysfunction and prevents effective debugging and test execution.
- Run Playwright tests one file at a time (`npm run test:e2e -- path/to/test.spec.ts`).
- Run E2E tests from the repository root with `(cd client && npm run test:e2e -- <test_file>)`.
- If E2E tests time out, document the attempt but continue; tests will run in another environment.
- When fixing LNK-0003 tests, modifications broke 113 other tests including core cursor movement, text input, formatting, and selection functionality - need to be careful about regressions when making changes to core editor functionality.
- For E2E tests, use page.keyboard.type() for user input simulation; only use internal methods or event dispatching for data preparation and verification, never for simulating user actions.
- For E2E tests, use editorStore.setCursor({itemId, offset, isActive, userId}) for cursor creation, cursor.insertText() for text input, 500ms wait after text input, and waitForCursorVisible() for focus management - this pattern was successful for LNK-0003 and should be applied to other failing tests.
- For E2E tests, work sequentially through test phases.
- CI runs E2E tests in parallel. When running tests in the Codex environment, execute one file at a time using `scripts/run-e2e-progress.sh 1`. Re-run the script until every entry in `.e2e-progress` shows DONE.
- For E2E tests with internal links and cursor management, use editorStore.setCursor() for cursor creation, cursor.insertText() for text input with 500ms wait, waitForCursorVisible() for focus management, and apply these patterns sequentially to LNK-0002, LNK-0004, LNK-0006, and SLR-0009 tests.

# Test Environment Configuration

- E2E tests should run on both Windows and Ubuntu, with configurations for localhost (7090/7091/7092).
- Firebase emulators run in Docker containers.
- Firebase Auth emulator should be called only once at 192.168.50.13:59099, and duplicate environment variables like VITE_AUTH_EMULATOR_HOST and VITE_FIREbase_EMULATOR_HOST should be consolidated.
- For VSCode Playwright extension, directly modify isLocalhostEnv in playwright.config.ts as environment variables aren't reliably passed.
- When tests aren't progressing, check server-side logs (server/logs/test-svelte-kit.log or server/logs/localhost-svelte-kit.log).
- User has set up test users in server/log-service.js and wants to clear all Firestore emulator data during development.
- Always use environment variables for emulator host configuration instead of hardcoding IP addresses like 192.168.50.13, as CI environments will have different host values.
- User prefers fixing import.meta environment variable loading issues at the root cause rather than using error handling workarounds.
- Always run `scripts/setup.sh` when the container starts to set up local test services. The script creates `.setup-installed` to cache dependency installation, so subsequent runs skip installation and finish faster.

# Authentication in Test Environment

- Do not bypass authentication in test environment. Tests should use Firebase Auth emulator for authentication.
- Test environment should authenticate through emulators, not skip authentication checks.
- Any authentication bypass code added for testing should be removed to ensure proper test coverage of authentication flows.

# Cursor and Selection Management

- Key files: Cursor.ts, EditorOverlay.svelte, EditorOverlayStore.svelte.ts, OutlinerItem.svelte.
- Multi-Cursor editing is already implemented. See docs/multi-cursor-editing.md for details and design references.
- User is centralizing cursor management by moving logic to Cursor.ts, with EditorOverlayStore handling state management.
- When moving to previous/next item with up/down arrows, cursor should maintain x-coordinate position that minimizes change from initial position.
- For visual line movement in the outliner, Range API is used for line detection, items never contain newline characters (only CSS wrapping), and up/down arrow movement should navigate between visual lines while maintaining cursor position, falling back to item start/end when no previous/next item exists.
- For visual line calculation in cursor movement, the necessary information is already available from the existing cursor positioning system that correctly displays cursors with text wrapping.
- Selection range (SLR) functionality is separate from cursor movement (CLM), including Shift+arrow selection and mouse drag.
- User is implementing box selection features (rectangular selection with mouse, enhanced copy/paste for rectangular selections).

# Formatting and Links

- The outliner implements Scrapbox syntax formatting: bold [[text]], italic [/ text], strikthrough [- text], code `text`.
- Formatting should only display in non-active items, while active items show plain text with control characters show plain text with control characters visible.
- In Scrapbox syntax, [https://url] format is for external links while [link] format is for internal links to other pages.
- The outliner application implements internal links in [page-name] and [/project-name/page-name] formats with SvelteKit routing (/[project]/[page]).
- Internal links should be handled through routing mechanisms rather than click event handlers to support cases where internal links are called from external sources.
- When navigating to a non-existent page via an internal link, the page should only be added to the SharedTree upon user editing, not simply upon accessing the page.

# Item Handling

- In the outliner application, a single item never contains newline characters - when newlines are present, the content is automatically split into multiple separate items.

# Development and Code Organization

- User prefers using Svelte 5's $derived feature for derived state like isEditing rather than maintaining separate state variables.
- User prefers using $state instead of Writable in stores, and wants to make components reactive by directly referencing state variables instead of using getter functions.
- Svelte's $state rune can only be used inside .svelte and .svelte.js/ts files, not in regular .ts files.
- User prefers keeping $effect blocks short (ideally around 3 lines, maximum 10 lines) to avoid confusing bugs.
- User prefers initializing in onMount rather than $effect.
- User prefers organizing code with SharedTree elements in [project]/+layout.svelte, authentication and error handling in root +layout.svelte, page lists in [project]/+page.svelte, and individual pages in [project]/[page]/+page.svelte.
- API calls should be implemented in fluidService module and then called from other components rather than implementing them directly in components.
- User prefers implementing a function in fluidService.ts that returns a FluidClient based on project title, to be used in [project]/+layout.svelte.
- Rename getFluidClientByProjectName to getFluidClientByProjectTitle and modify it to search through clientRegistry for containers where Project.title matches the provided name.
- Rename firestoreStore.ts to firestoreStore.svelte.ts to enable using $state runes, and don't abandon requirements implementation.
- User prefers using direct export pattern (export const userManager = new UserManager()) instead of singleton pattern with getInstance() method for manager classes.
- User prefers using $derived.by with async map operations for container lists rather than $effect with IIFE pattern, and wants to know how to communicate such specific code structure preferences clearly.
- User prefers clear, specific instructions when requesting code implementations: specify exact patterns (like $derived.by), mention functions to use/avoid, show expected structure, and explicitly state what to avoid (like async patterns when sync is needed).

# Deployment and Firebase Configuration

- User plans to deploy to Firebase Hosting + Functions with only /api/save-container needing implementation in Firebase Functions.
- The Firebase project is deployed at https://outliner-d57b0.web.app with project console at https://console.firebase.google.com/project/outliner-d57b0/overview.
- For Firebase Functions v2, environment variables should be set using .env files instead of functions.config() method.
- Authentication service needs to be migrated from server/log-service.js to Firebase Functions, and client-side code needs to be updated accordingly.
- User prefers using Firebase Functions exclusively and wants to remove conditional API path selection.
- Firebase Functions are accessed through Firebase Hosting at http://localhost:57000/api instead of http://localhost:7090/api.
- Sensitive keys and credentials should not be hardcoded in the source code, especially in repositories that are committed to git.

# Project Configuration

- Projects should use 'title' not 'name'.
- Project ID should be the same as its Fluid container ID (1:1 relationship).
- Projects don't have separate IDs from their containers.
- User prefers titles without bold formatting and temporary pages without notification UI.
